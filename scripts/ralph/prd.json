{
  "project": "Bullseye",
  "branchName": "ralph/scout-state-persistence",
  "description": "Fix SCOUT tab loading bug and add database-first state persistence for reader analysis, focus groups, and executive evals across tab switches and devices",
  "userStories": [
    {
      "id": "US-001",
      "title": "Investigate and fix SCOUT initialization race condition",
      "description": "As a developer, I need to fix the race condition in scout-chat.tsx where the chat history loading useEffect (triggered by currentProject change) conflicts with the pendingScoutAttachment detection, causing 'Loading conversation' to get stuck on new project uploads.",
      "acceptanceCriteria": [
        "The chat history loading useEffect (watches currentProject) does not block or reset state needed by the pendingScoutAttachment useEffect",
        "For new projects with no chat history, the history fetch resolves immediately (empty array) without showing a prolonged loading state",
        "The pendingScoutAttachment useEffect waits for history loading to complete (or skips waiting for new projects with no history) before triggering handleSendMessage",
        "Add an isHistoryLoaded ref or state flag that the attachment effect checks before firing",
        "When a script is uploaded to a new project, SCOUT conversation appears on the left within 2 seconds",
        "Works for both new projects and existing projects with new drafts",
        "Typecheck passes",
        "Verify in browser using dev-browser skill"
      ],
      "priority": 1,
      "passes": true,
      "notes": "The race condition: setCurrentProject() triggers the chat history fetch useEffect which may clear/reset state. Meanwhile pendingScoutAttachment is set but its useEffect either hasn't fired yet or fires during the loading state. The fix should coordinate these two effects so attachment processing happens after history is ready."
    },
    {
      "id": "US-002",
      "title": "Add progress indicators for SCOUT initialization",
      "description": "As a user, I want clear visual feedback during SCOUT initialization so I understand what's happening instead of seeing an indefinite loading spinner.",
      "acceptanceCriteria": [
        "When SCOUT is initializing after upload, show a stepped progress indicator with phases: 'Processing script' → 'Starting analysis' → 'Readers engaging'",
        "Progress state is derived from SSE events: tool_start triggers 'Starting analysis', reader_start triggers 'Readers engaging'",
        "If initialization takes more than 10 seconds without a new phase, show 'Still working...' text (not an error state)",
        "If initialization fails (onError fires), show a clear error message with a retry button",
        "The progress indicator replaces the 'Loading conversation' spinner during initialization",
        "Typecheck passes",
        "Verify in browser using dev-browser skill"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Add a scoutInitPhase state ('idle' | 'processing' | 'analyzing' | 'engaging' | 'error') that updates based on SSE event callbacks. Display this as a stepped indicator in the chat area during initialization."
    },
    {
      "id": "US-003",
      "title": "Add ReaderAnalysisState database model",
      "description": "As a developer, I need a database model to persist per-reader analysis state so it survives tab switches and is accessible across devices.",
      "acceptanceCriteria": [
        "Add ReaderAnalysisState model to prisma/schema.prisma with fields: id (cuid), draftId (String), readerId (String), status ('pending' | 'streaming' | 'complete' | 'error'), progress (Int, 0-100), scores (Json? — { premise, character, dialogue, structure, commerciality, overall }), recommendation (String?), keyStrengths (String[]), keyConcerns (String[]), standoutQuote (String?), error (String?), createdAt, updatedAt",
        "Add @@unique([draftId, readerId]) constraint — one state per reader per draft",
        "Add relation: Draft has many ReaderAnalysisStates (cascade delete)",
        "Run Prisma migration successfully",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "This model stores the ACTIVE session state (in-progress analysis), separate from ReaderMemory which stores COMPLETED analysis for cross-draft continuity. ReaderAnalysisState is the 'hot' state for UI rendering; ReaderMemory is the 'cold' state for context injection."
    },
    {
      "id": "US-004",
      "title": "Add scoutPhase field to ChatSession model",
      "description": "As a developer, I need to persist the right panel's current phase so users return to the correct view when switching tabs.",
      "acceptanceCriteria": [
        "Add scoutPhase field (String?, default null) to the ChatSession model — stores: 'idle' | 'analysis' | 'focus_group' | 'reader_chat' | 'executive'",
        "Run Prisma migration successfully",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "This field persists the rightPanelMode value. When null, defaults to 'idle' on the client side."
    },
    {
      "id": "US-005",
      "title": "Create scout-state API endpoint for reading state",
      "description": "As a developer, I need a GET endpoint that returns the full SCOUT tab state for a project's current draft.",
      "acceptanceCriteria": [
        "Create GET /api/projects/[id]/scout-state endpoint",
        "Returns: { readerStates: ReaderAnalysisState[], focusGroupMessages: FocusGroupMessage[], executiveEvals: ExecutiveEvaluation[], scoutPhase: string | null }",
        "readerStates: fetches from ReaderAnalysisState table for the project's latest draft",
        "focusGroupMessages: fetches from FocusGroupMessage table for the latest draft's most recent FocusSession",
        "executiveEvals: fetches from ExecutiveEvaluation table for the latest draft (if model exists, otherwise empty array)",
        "scoutPhase: fetches from ChatSession.scoutPhase for this project",
        "Verifies user authentication and project ownership",
        "Returns empty arrays/null if no data exists (not 404)",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "The endpoint assembles state from multiple tables. Use Promise.all for parallel DB queries. The 'latest draft' is determined by highest draftNumber for the project."
    },
    {
      "id": "US-006",
      "title": "Create scout-state API endpoint for writing state",
      "description": "As a developer, I need a PUT endpoint to persist partial SCOUT state updates from the client.",
      "acceptanceCriteria": [
        "Create PUT /api/projects/[id]/scout-state endpoint",
        "Request body: { readerStates?: Array<{ readerId, status, progress?, scores?, recommendation?, keyStrengths?, keyConcerns?, standoutQuote?, error? }>, scoutPhase?: string }",
        "For readerStates: upserts each ReaderAnalysisState record (keyed by draftId + readerId) for the project's latest draft",
        "For scoutPhase: updates the ChatSession.scoutPhase field (upserts ChatSession if needed)",
        "Verifies user authentication and project ownership",
        "Returns { success: true } on success",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "This endpoint handles debounced writes from the client during SSE streaming. Use db.$transaction for atomic multi-reader updates."
    },
    {
      "id": "US-007",
      "title": "Persist reader states during SSE streaming",
      "description": "As a developer, I need SSE event handlers to write reader analysis state to the database via debounced API calls.",
      "acceptanceCriteria": [
        "In scout-chat.tsx, create a debounced function (500ms) that calls PUT /api/projects/[id]/scout-state with current readerStates",
        "The debounced function is triggered on onReaderStart, onReaderProgress, and onReaderComplete callbacks",
        "On onReaderComplete, flush immediately (no debounce) to ensure final state is persisted",
        "Persistence is fire-and-forget — failures are caught and logged but don't interrupt the UI",
        "Only fires if currentProject?.id is available",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Use a useRef to hold the debounce timer. The debounced function reads current readerStates from the Zustand store and sends the full array to the PUT endpoint. On complete events, call the function directly bypassing debounce."
    },
    {
      "id": "US-008",
      "title": "Persist scoutPhase on right panel mode changes",
      "description": "As a developer, I need the right panel phase to persist to the database when it changes.",
      "acceptanceCriteria": [
        "When setRightPanelMode (or equivalent) is called in the Zustand store, also fire a PUT /api/projects/[id]/scout-state with { scoutPhase: newMode }",
        "This is fire-and-forget — failures are caught and logged",
        "Only fires if currentProject?.id is available",
        "The phase is persisted for: 'analysis', 'focus_group', 'reader_chat', 'executive' (not 'idle' — null means idle)",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Can be done by modifying the setRightPanelMode action in the Zustand store to include a side-effect, or by adding a useEffect in a component that watches rightPanelMode changes."
    },
    {
      "id": "US-009",
      "title": "Hydrate SCOUT tab state from database on mount",
      "description": "As a user, I want to see all my previous SCOUT activity when I return to the SCOUT tab, so I never lose progress.",
      "acceptanceCriteria": [
        "On SCOUT tab mount (or when currentProject changes), fetch GET /api/projects/[id]/scout-state",
        "Populate Zustand readerStates Map from the API response's readerStates array",
        "Set rightPanelMode from the API response's scoutPhase (default to 'idle' if null)",
        "Populate focusGroupMessages from the API response (if focus group data exists)",
        "Show per-section loading skeletons while fetching (not one global spinner)",
        "If local Zustand already has data for the current project, render it immediately and reconcile with DB in background (DB wins if newer based on updatedAt)",
        "Typecheck passes",
        "Verify in browser using dev-browser skill"
      ],
      "priority": 9,
      "passes": true,
      "notes": "This hydration happens in addition to the existing chat history loading. The scout-state fetch can run in parallel with the chat history fetch for faster mount."
    },
    {
      "id": "US-010",
      "title": "Stop clearing SCOUT state on tab switches",
      "description": "As a developer, I need to ensure that switching tabs does NOT wipe SCOUT-related state from Zustand.",
      "acceptanceCriteria": [
        "The setActiveTab action in the Zustand store does NOT clear readerStates, focusGroupMessages, executiveStates, or rightPanelMode",
        "Only setCurrentProject (when project ID actually changes) triggers state reload from DB",
        "Switching from SCOUT to Coverage and back preserves all reader analysis cards, scores, and panel state",
        "Verify: upload a script, wait for reader analysis to appear, switch to another tab, switch back — all reader data is still visible",
        "Typecheck passes",
        "Verify in browser using dev-browser skill"
      ],
      "priority": 10,
      "passes": false,
      "notes": "Check if setActiveTab or any component unmount handlers are clearing SCOUT state. The resetProjectState action should only fire on project change, not tab change. If ScoutChat/ScoutLayout unmount clears state, that needs to be removed."
    },
    {
      "id": "US-011",
      "title": "Ensure multi-device access shows latest state",
      "description": "As a user, I want to access my SCOUT progress from any device.",
      "acceptanceCriteria": [
        "All SCOUT state (chat, reader analysis, focus group, executive evals) is fetched fresh from DB on page load — not from localStorage",
        "Remove readerStates, focusGroupMessages, executiveStates, and rightPanelMode from the Zustand persist whitelist (if they are currently persisted)",
        "LocalStorage/Zustand persist is used only for UI preferences (expanded cards, active tab, current studio) not for analysis data",
        "If a user opens the same project on two devices, the second device shows the latest persisted state from DB",
        "No conflicts if one device has stale local cache — DB always wins on reload",
        "Typecheck passes"
      ],
      "priority": 11,
      "passes": false,
      "notes": "Check the Zustand persist partialize function in app-store.ts. Ensure ephemeral SCOUT state is NOT in the persist whitelist. The hydration from US-009 handles loading fresh from DB on mount."
    }
  ]
}
