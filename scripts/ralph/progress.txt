# Ralph Progress Log
Started: Thu Jan 22 16:30:42 PST 2026

## Codebase Patterns
- Prisma 7 uses `prisma.config.ts` for database URLs — NOT `url`/`directUrl` in schema.prisma datasource block
- Prisma 7 CLI flags changed: use `--to-schema` instead of `--to-schema-datamodel`, use `-o` for output file
- db.ts uses PrismaClient with PrismaPg adapter (pg Pool) — standard Prisma 7 adapter pattern
- Studio and User have circular FK dependency — use pg pool with `SET CONSTRAINTS ALL DEFERRED` for seeding
- Seed script uses `tsx` to run TypeScript directly — added as dev dependency
- Pre-existing type errors exist in agent-sdk tools — `next.config.ts` has `ignoreBuildErrors: true`
- db.ts exports `db` (named) and `default` — use `import { db } from '@/lib/db'` in routes
- Default studio ID is `'default-studio-id'` — use this constant for user provisioning
- User provisioning happens at 3 points: login page fetch, auth callback server-side, and getCurrentUser() fallback in auth.ts
- `.env*` is gitignored — `.env.example` is exempted with `!.env.example`
- Generated Prisma client outputs to `src/generated/prisma` — imported as `@/generated/prisma/client`
- Toast store is a separate Zustand store at `src/stores/toast-store.ts` — use `useToastStore` with `addToast(message, variant)`
- ToastContainer is rendered in `src/app/providers.tsx` — no need to add it per-page
- Design system has semantic color vars: `--success`, `--warning`, `--danger`, `--info` — use as Tailwind classes `bg-success`, `text-danger`, etc.
- React Query hooks go in `src/hooks/` — export query key factories (e.g., `projectKeys`) for external invalidation
- React Query v5 useMutation needs 4th generic `TContext` for typed optimistic update rollback
- API routes use `getCurrentUser()` from `@/lib/auth` — returns null if unauthed, user includes `studioId` for scoping
- Next.js 15 dynamic route params are a Promise — use `const { id } = await params` (type: `{ params: Promise<{ id: string }> }`)
- Access control: always check `project.studioId !== user.studioId` to prevent cross-studio access
- Home view no longer uses Zustand `projects` array — uses `useProjects()` React Query hook, which returns `ProjectWithCount[]` with `_count.drafts`
- Project creation uses `useCreateProject` mutation — onSuccess sets Zustand state and navigates, onError shows toast
- Supabase admin client at `src/lib/supabase/admin.ts` — uses service role key for server-side storage/RLS bypass
- Draft upload route auto-increments `draftNumber` by querying latest draft for the project
- PDF extraction returns both `text` and `pageCount` — Draft model stores both
- Draft hooks go in `src/hooks/use-drafts.ts` — useUploadDraft sends FormData, invalidates projectKeys on success
- DraftStatus type: 'PENDING' | 'ANALYZING' | 'COMPLETED' | 'FAILED' — use these exact values
- Scout chat messages stored in Zustand `chatMessages` (not local state) — persists across tab switches but not page refreshes
- `updateChatMessage(id, updates)` in app-store for targeted message updates during streaming
- SSE connection via `createSSEConnection(url, body, callbacks)` from `@/lib/agent-sdk/event-router`
- StoreChatMessage type exported from app-store — matches ChatMessage from chat-interface.tsx (timestamp optional)
- Tool status pills are tracked via `toolCalls: ToolCallStatus[]` on the assistant message — updated via `updateChatMessage(id, { toolCalls })` during streaming
- MCP tool names prefixed with `mcp__bullseye-tools__` — strip with `tool.split('__').pop()` to get the base name for TOOL_DISPLAY_NAMES lookup
- Event router auto-switches rightPanelMode based on SSE source — reader sources → 'analysis', focus_group → 'focus_group', reader_chat/executive → their respective modes
- Phase change guard in scout-chat's onPhaseChange callback prevents redundant mode switches and side effects (check `useAppStore.getState().rightPanelMode !== phase` before acting)
- Reader chat messages stored in Zustand `readerChatMessages` (Record<string, ReaderChatMessage[]>) — keyed by readerId, persists across panel switches
- `addReaderChatMessage(readerId, msg)` and `updateReaderChatMessage(readerId, msgId, updates)` for per-reader message management
- Executive streaming states stored in Zustand `executiveStates` Map<string, ExecutiveStreamState> — accumulates results, persists across panel switches
- When adding new EventRouterCallbacks, also update focus-group-panel.tsx (has its own inline callbacks for follow-up messages)
- Draft access control: `include: { project: { select: { studioId: true } } }` then check `draft.project.studioId !== user.studioId`
- DraftDeliverable has unique constraint on `draftId` — use `findUnique({ where: { draftId: id } })` not findFirst
- Studio sub-entity (readers/executives) access control: check `entity.studioId !== user.studioId` directly — no join needed
- StudioIntelligence has unique constraint on `studioId` — use `findUnique({ where: { studioId } })`
- PUT routes for partial updates: use conditional spread `...(body.field !== undefined && { field: body.field })` for each updatable field
- draftKeys exported from `src/hooks/use-drafts.ts` — use `draftKeys.deliverable(id)`, `draftKeys.evaluations(id)`, `draftKeys.focusSessions(id)` for cache invalidation
- studioKeys exported from `src/hooks/use-studio.ts` — use `studioKeys.studio`, `studioKeys.readers`, `studioKeys.executives`, `studioKeys.intelligence` for cache invalidation
- Hooks that fetch optional data (deliverable, intelligence) return `null` for 404 — check `data === null` for empty state, not just `!data` (which also matches loading)

---

## 2026-01-22 - US-001
- What was implemented:
  - Prisma migration (0001_init) generated from schema and marked as applied
  - prisma.config.ts updated with DIRECT_URL fallback for migrations
  - .env.example created with all required env vars
  - Seed script at scripts/seed.ts with Studio, 3 Readers, 5 Executives, StudioIntelligence
  - npm scripts: db:seed, db:migrate, db:generate
  - .gitignore updated to allow .env.example
  - tsx added as dev dependency
- Files changed:
  - .env.example (new)
  - .gitignore (modified)
  - prisma.config.ts (modified)
  - prisma/schema.prisma (modified — pre-existing changes included)
  - prisma/migrations/0001_init/migration.sql (new)
  - scripts/seed.ts (new)
  - package.json (modified)
  - package-lock.json (modified)
- **Learnings for future iterations:**
  - Prisma 7 removed `url` and `directUrl` from schema datasource block — must use prisma.config.ts
  - `prisma migrate diff` uses `--to-schema` flag (not `--to-schema-datamodel`)
  - Circular FK between Studio/User means you can't use Prisma ORM for initial insert — use raw pg pool with deferred constraints
  - The database already has tables from prior setup — use `prisma migrate resolve --applied` to baseline
  - tsx is needed as a dev dep to run seed.ts; npx tsx works but installs each time
---

## 2026-01-22 - US-002
- What was implemented:
  - User provisioning API route at src/app/api/auth/provision/route.ts
  - Login page updated to call /api/auth/provision after successful signInWithPassword
  - Auth callback updated to provision user server-side after exchangeCodeForSession
  - Fixed auth.ts type error — changed from nested studio create to studioId reference
  - auth.ts getCurrentUser() also provisions users as fallback
- Files changed:
  - src/app/api/auth/provision/route.ts (new)
  - src/app/auth/callback/route.ts (modified)
  - src/app/login/page.tsx (modified — added provision call)
  - src/lib/auth.ts (modified — fixed type error, use DEFAULT_STUDIO_ID)
- **Learnings for future iterations:**
  - db.ts exports as `{ db }` named export, not `{ prisma }`
  - The circular FK between Studio/User means you can't use nested `studio: { create: {} }` from User create — use studioId directly
  - auth.ts previously had a type error from trying to create Studio in nested User create — fixed by referencing default studio
  - Login page UI was already redesigned with Framer Motion animations in the working tree (pre-existing changes on branch)
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-003
- What was implemented:
  - Toast store at src/stores/toast-store.ts — Zustand store with addToast(message, variant) and removeToast(id)
  - Toast component at src/components/shared/toast.tsx — renders fixed bottom-right, stacks vertically with 8px gap
  - Supports 4 variants: success (green), error (red), warning (amber), info (blue) using design system color vars
  - Auto-dismisses after 5 seconds, also dismissible on click
  - Framer Motion AnimatePresence: enter (slide up + fade in + scale), exit (slide right + fade out)
  - Each toast has icon (CheckCircle, XCircle, AlertTriangle, Info from lucide-react)
  - ToastContainer added to providers.tsx so it renders on all pages
- Files changed:
  - src/stores/toast-store.ts (new)
  - src/components/shared/toast.tsx (new)
  - src/app/providers.tsx (modified — added ToastContainer import and render)
- **Learnings for future iterations:**
  - Toast store is intentionally separate from app-store — it's ephemeral UI state that shouldn't persist
  - Use `useToastStore.getState().addToast(msg, variant)` for non-component contexts (e.g., API error handlers)
  - Framer Motion `mode="popLayout"` is needed for smooth layout animations when toasts are removed from middle of stack
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-004
- What was implemented:
  - React Query hooks file at src/hooks/use-projects.ts
  - useProjects() hook: fetches GET /api/projects, returns ProjectWithCount[] (with _count.drafts), staleTime 30s
  - useProject(id) hook: fetches GET /api/projects/[id], returns ProjectWithDrafts (with drafts array), staleTime 30s, enabled only when id is truthy
  - useCreateProject() mutation: POST /api/projects, optimistic update (adds temp project to list immediately), rolls back on error, invalidates on settle
  - projectKeys query key factory exported for external cache invalidation
  - MutationContext type for proper onError context typing
  - QueryClientProvider was already set up in providers.tsx (from prior work)
- Files changed:
  - src/hooks/use-projects.ts (new)
- **Learnings for future iterations:**
  - QueryClientProvider is already in src/app/providers.tsx — no need to add it again
  - React Query v5 requires explicit 4th generic type param on useMutation for context typing (TData, TError, TVariables, TContext)
  - Project type in types/index.ts has optional `drafts?: Draft[]` — use Omit<Project, 'drafts'> when API returns different shape
  - Pre-existing type errors in agent-sdk tools are expected and not blockers (next.config.ts has ignoreBuildErrors: true)
  - projectKeys pattern: `all: ['projects']`, `detail: (id) => ['projects', id]` — follow this for other entity hooks
---

## 2026-01-22 - US-005
- What was implemented:
  - GET /api/projects — returns projects for authenticated user's studio, ordered by updatedAt desc, with _count.drafts
  - POST /api/projects — creates project with title, logline, genre, format; validates required fields (400 if missing)
  - GET /api/projects/[id] — returns project with drafts array ordered by draftNumber desc
  - All routes validate auth via getCurrentUser() — return 401 if unauthenticated
  - GET by ID also validates studio membership — returns 404 if project belongs to different studio
  - Returns 404 for non-existent project IDs
- Files changed:
  - src/app/api/projects/route.ts (new)
  - src/app/api/projects/[id]/route.ts (new)
- **Learnings for future iterations:**
  - API route pattern: use `getCurrentUser()` from `@/lib/auth` for auth, return 401 if null
  - Project access control: check `project.studioId !== user.studioId` to prevent cross-studio access
  - Next.js 15 dynamic route params are now a Promise — use `const { id } = await params` in route handlers
  - Include `_count: { select: { drafts: true } }` for list endpoints that need relation counts
  - POST routes should return 201 status on successful creation
---

## 2026-01-22 - US-006
- What was implemented:
  - Home view (`home-view.tsx`) refactored to use `useProjects()` React Query hook instead of Zustand store
  - Loading state shows 3 skeleton project cards with pulse animation
  - Empty state with 48px Target icon, "Create your first project" heading, and "New Project" button
  - Project cards display real data: title, logline, format badge, draft count from `_count.drafts`, last updated date
  - Error state for failed fetches
  - Project creation modal (`project-create-modal.tsx`) wired to `useCreateProject` mutation
  - Success toast on project creation, error toast on failure
  - Selecting a project calls `setCurrentProject` in Zustand and switches to Scout tab
  - Create button disabled while mutation is pending
- Files changed:
  - src/components/home/home-view.tsx (rewritten — uses useProjects hook, added skeleton loading)
  - src/components/home/project-create-modal.tsx (modified — uses useCreateProject mutation + toasts)
- **Learnings for future iterations:**
  - The `useProjects()` hook returns `ProjectWithCount[]` which has `_count: { drafts: number }` — use this instead of `project.drafts?.length`
  - Pre-existing type errors in agent-sdk tools don't block the build (ignoreBuildErrors: true in next.config.ts)
  - For optimistic updates with React Query, the modal's `onSuccess` callback is where you set Zustand state (setCurrentProject) and navigate
  - The home view no longer uses currentStudio from Zustand — the API already scopes projects by studio via the auth session
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-007
- What was implemented:
  - POST /api/projects/[id]/drafts — accepts multipart form data with PDF file and optional notes
  - Validates auth, project ownership (studio scoping), file type (PDF only), file size (10MB max)
  - Extracts text from PDF using pdfjs-dist (reuses same approach as /api/upload)
  - Stores PDF in Supabase Storage bucket 'scripts' at path '{projectId}/{draftNumber}.pdf'
  - Creates Draft record with auto-incremented draftNumber, scriptText, pageCount, notes, scriptUrl
  - Returns created Draft with id, draftNumber, pageCount, status, scriptUrl (201)
  - Supabase admin client created at src/lib/supabase/admin.ts for service-role storage operations
- Files changed:
  - src/app/api/projects/[id]/drafts/route.ts (new)
  - src/lib/supabase/admin.ts (new)
- **Learnings for future iterations:**
  - Supabase Storage upload needs service role key to bypass RLS — use createAdminClient() not the user-scoped client
  - getPublicUrl() is synchronous (no await needed) and returns `{ data: { publicUrl: string } }`
  - Draft draftNumber auto-increment: query `findFirst` with `orderBy: { draftNumber: 'desc' }` then add 1
  - The /api/upload route already has PDF extraction logic — for the drafts route we duplicated it locally to also return pageCount
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-008
- What was implemented:
  - useUploadDraft mutation hook at src/hooks/use-drafts.ts — POST FormData to /api/projects/[id]/drafts
  - DraftUploadModal refactored to use useUploadDraft mutation instead of local Zustand state
  - Upload progress indicator: Loader2 spinning icon + "Extracting text..." message during API call
  - Success toast: "Draft uploaded — {pageCount} pages extracted"
  - Error toast: shows the API error message for corrupt/password-protected PDFs
  - After success: invalidates project query (projects list + detail) so draft count updates
  - Modal closes on success, stays open on error
  - All interactive elements disabled during upload (backdrop click, close button, cancel, notes textarea)
  - setCurrentDraft called on success with proper DraftStatus type cast
- Files changed:
  - src/hooks/use-drafts.ts (new — useUploadDraft mutation hook)
  - src/components/home/draft-upload-modal.tsx (rewritten — wired to API with progress/toasts)
- **Learnings for future iterations:**
  - DraftStatus type is 'PENDING' | 'ANALYZING' | 'COMPLETED' | 'FAILED' — not 'COMPLETE' or 'ERROR'
  - useMutation.isPending is the React Query v5 way to check loading state (replaces isLoading)
  - uploadMutation.reset() should be called in resetAndClose to clear error state on re-open
  - The draft upload API returns pageCount as `number | null` — use nullish coalescing for display
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-009
- What was implemented:
  - Refactored scout-chat.tsx to use Zustand store's `chatMessages` and `isStreaming` instead of local useState
  - Messages now persist across tab switches within the session (stored in Zustand, not localStorage)
  - Added `updateChatMessage(id, updates)` method to store for targeted message updates during streaming
  - Added `StoreChatMessage` exported type to app-store matching ChatMessage fields (with optional timestamp)
  - SSE streaming works via `createSSEConnection` from event-router.ts (already existed)
  - text_delta events append content token-by-token to assistant message via `updateChatMessage`
  - text_complete events finalize message by setting `isStreaming: false`
  - Error handling: connection failures show system error message in chat with "Click Retry" text
  - Retry button appears below chat when error messages exist — cleans up error messages and resends last request
  - system type=error SSE events display as red error messages (system role messages in ChatInterface)
  - Input disabled during streaming via Zustand `isStreaming` state
- Files changed:
  - src/stores/app-store.ts (modified — added StoreChatMessage type, updateChatMessage method, optional timestamp)
  - src/components/scout/scout-chat.tsx (rewritten — uses Zustand chatMessages, added retry mechanism)
- **Learnings for future iterations:**
  - ChatMessage from chat-interface.tsx has `timestamp?: Date` (optional) — StoreChatMessage must match
  - `useAppStore.getState()` is used in handleRetry for direct state access outside React rendering
  - `useAppStore.setState({ chatMessages: filtered })` can be used for bulk state updates not covered by actions
  - chatMessages are NOT in the persist partialize — they persist in memory across tab switches but not page refreshes
  - Error markers use `__error__:` prefix in system messages for internal tracking, stripped for display
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-010
- What was implemented:
  - Inline tool status pills rendered on the assistant message during Scout tool calls
  - tool_start events add a ToolCallStatus entry (running) with gold spinner pill
  - tool_end events update the matching pill to complete state (green checkmark)
  - ToolCallStatus type added to both app-store (StoreChatMessage.toolCalls) and chat-interface (ChatMessage.toolCalls)
  - Pills rendered via Framer Motion scale-in animation within the MessageBubble component
  - TOOL_DISPLAY_NAMES mapping updated per AC: spawn_readers → 'Analyzing with readers...', focus_group → 'Running focus group...', executive_eval → 'Evaluating with executives...', reader_chat → 'Chatting with reader...'
  - File attachment feature (Paperclip button, file picker, drag-and-drop, PDF upload via /api/upload, filename chip) was already present in ChatInterface from working tree — committed as part of US-010
  - onResult handler marks any remaining running tools as complete
  - currentAssistantIdRef and toolCallsRef track the active message's tool state across callbacks
- Files changed:
  - src/stores/app-store.ts (modified — added ToolCallStatus interface, toolCalls field on StoreChatMessage)
  - src/components/chat/chat-interface.tsx (modified — added ToolCallStatus interface, toolCalls on ChatMessage, tool pill rendering in MessageBubble, full file attachment UI)
  - src/components/scout/scout-chat.tsx (modified — added tool call tracking refs, updated onToolStart/onToolEnd/onResult handlers)
- **Learnings for future iterations:**
  - Tool pills are tracked as an array on the assistant message (toolCalls) rather than separate system messages — this keeps them visually grouped with the response
  - Use refs (currentAssistantIdRef, toolCallsRef) for callback-scoped state that needs to persist across SSE events without causing re-renders
  - MCP tool names come as 'mcp__bullseye-tools__ingest_script' — strip prefix with split('__').pop() to get base name for display mapping
  - The ToolCallStatus type is defined in both app-store and chat-interface — they're structurally identical so TypeScript treats them as compatible
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-011
- What was implemented:
  - SSE event routing automatically switches right panel mode based on event source
  - reader_maya/reader_colton/reader_devon source with analysis_start type → switches to 'analysis' mode
  - focus_group source events → switches to 'focus_group' mode
  - reader_chat source events → switches to 'reader_chat' mode
  - executive source events → switches to 'executive' mode
  - ScoutEventSource type extended with 'reader_chat' and 'executive' sources
  - Phase change guard in scout-chat prevents redundant updates (checks current mode before switching)
  - Prevents focus group messages from being cleared if already in focus_group mode
  - Framer Motion transitions updated from 300ms to 200ms per AC
  - Idle state shows 'Reader activity will appear here' (exact AC text)
  - ScoutLayout renders 5 panel modes: idle, analysis, focus_group, reader_chat, executive
  - All non-idle panels use fade+slide animation (opacity 0→1, x: 20→0 enter, x: 0→-20 exit)
- Files changed:
  - src/lib/agent-sdk/types.ts (modified — added reader_chat and executive to ScoutEventSource)
  - src/lib/agent-sdk/event-router.ts (modified — auto-switch panel mode on source-based events, added reader_chat/executive cases)
  - src/components/scout/scout-layout.tsx (modified — updated idle text, changed transition duration to 0.2s)
  - src/components/scout/scout-chat.tsx (modified — added phase change guard to prevent redundant updates)
- **Learnings for future iterations:**
  - Radix ScrollArea doesn't forward refs — use native `div` with `overflow-y-auto` when you need scrollTop access
- For follow-up inputs in sub-panels, wire full EventRouterCallbacks to createSSEConnection — use `useAppStore.getState()` in callbacks
- Event router's `routeEvent` function switches on `event.source` — new source types need case statements here
  - Phase change guard pattern: `const currentMode = useAppStore.getState().rightPanelMode; if (currentMode !== phase) { ... }` prevents redundant state updates and side effects like clearing messages
  - ScoutLayout uses AnimatePresence with `mode="wait"` for sequential panel transitions (exit → enter, not overlap)
  - focus_group source events fire for every message — calling onPhaseChange every time is fine since the guard in scout-chat prevents redundant updates
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-012
- What was implemented:
  - Reader analysis right panel with live streaming results, expandable/collapsible cards, and harmonized scores
  - 3 reader cards (Maya, Colton, Devon) with colored left borders when complete
  - reader_start events set card to 'Analyzing...' with pulse animation (or progress bar if progress events arrive)
  - reader_progress events (via analysis_stream SSE type) update a progress bar on the reader card
  - reader_complete events populate: recommendation badge, overall score bar, strengths, concerns, standout quote
  - ScoreBars component: 10-bar visualization with staggered left-to-right fill animation (300ms duration, 50ms stagger per bar)
  - Harmonized Scores section appears at top after all 3 readers complete — averages all reader scores
  - Cards are expandable/collapsible using Zustand expandedReaders state with ChevronDown rotation
  - Collapsed card shows overall score + recommendation; expanded shows all dimension scores + strengths/concerns/quote
  - Added progress field to ReaderStreamState type
  - Added onReaderProgress callback to EventRouterCallbacks
  - Added analysis_stream routing in event-router for progress updates
- Files changed:
  - src/components/scout/reader-analysis-panel.tsx (rewritten — expandable cards, score bars, harmonized scores, progress indicator)
  - src/lib/agent-sdk/types.ts (modified — added progress field to ReaderStreamState)
  - src/lib/agent-sdk/event-router.ts (modified — added onReaderProgress callback, analysis_stream routing)
  - src/components/scout/scout-chat.tsx (modified — added onReaderProgress handler, progress init on reader start)
- **Learnings for future iterations:**
  - expandedReaders and toggleReaderExpanded are already in Zustand UI state — use these for any expand/collapse patterns
  - ScoreBars uses Framer Motion scaleX with transformOrigin: 'left' for left-to-right fill animation
  - numericToFilled(value) converts 0-100 scores to 0-10 filled bars (Math.round(value / 10))
  - computeHarmonizedScores iterates all 3 readers and averages per dimension — graceful with missing data
  - analysis_stream is the SSE event type for reader progress updates (not a separate reader_progress type)
  - AnimatePresence with height: 0/auto for expand/collapse transitions needs overflow-hidden on the motion.div
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-013
- What was implemented:
  - Focus group panel with chat-style message list, reader avatars, and colors
  - focus_group_message SSE events append messages with reader name, color, and avatar (was already wired via event-router)
  - Moderator (Scout) messages styled with gold accent border (border-l-2, #D4A84B color)
  - Typing indicator shows reader name + animated dots before message arrives
  - Messages auto-scroll to bottom via native div with overflow-y-auto + useEffect scrollTop
  - Follow-up question input at bottom — sends user message to Scout via /api/scout SSE
  - Follow-up input wires full EventRouterCallbacks so focus group messages still route to Zustand
  - Messages stored in Zustand focusGroupMessages array (persists across tab switches)
- Files changed:
  - src/components/scout/focus-group-panel.tsx (rewritten — added gold border, follow-up input, scroll fix, proper ES imports)
- **Learnings for future iterations:**
  - Radix ScrollArea doesn't forward refs to the viewport — use native `div` with `overflow-y-auto` when you need `scrollRef.current.scrollTop` access
  - For follow-up inputs in sub-panels (focus group, reader chat), wire a full EventRouterCallbacks object to createSSEConnection — use `useAppStore.getState()` in callbacks for fresh state
  - Gold accent color for moderator/Scout is `#D4A84B` — use `border-l-2` with inline `borderLeftColor` style (Tailwind can't do arbitrary colors inline)
  - The focus-group-panel.tsx file was previously untracked — it's a new file in this branch
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-014
- What was implemented:
  - Reader chat right panel with per-reader conversation history in Zustand
  - ReaderChatMessage type and readerChatMessages (Record<string, ReaderChatMessage[]>) added to Zustand store
  - addReaderChatMessage(readerId, message) and updateReaderChatMessage(readerId, messageId, updates) actions added
  - Conversations persist per reader — switching readers or navigating away doesn't lose history
  - Back button (ChevronLeft) returns to reader selector without clearing messages
  - Header shows "Chatting with {reader.name}" per AC
  - Native div with overflow-y-auto replaces Radix ScrollArea for proper scrollTop ref access
  - Reader selector shows 3 avatars with colored circles and initials
  - SSE streaming via POST /api/reader-chat with readerId, message, projectId, draftId, conversationHistory
  - text_delta events stream token-by-token into assistant message via updateReaderChatMessage
  - text_complete events finalize the message
  - Typing indicator with animated dots while waiting for first token
  - Error handling updates assistant message with error text
- Files changed:
  - src/stores/app-store.ts (modified — added ReaderChatMessage type, readerChatMessages state, add/update actions)
  - src/components/scout/reader-chat-panel.tsx (rewritten — uses Zustand for per-reader message persistence)
- **Learnings for future iterations:**
  - Per-reader chat messages are stored as Record<string, ReaderChatMessage[]> keyed by readerId — not a flat array
  - Back button only clears activeReaderChatId (not messages) — this preserves history when returning to selector
  - ReaderChatMessage is exported from app-store for use in the panel component's ChatBubble props
  - The reader-chat-panel.tsx was previously untracked — it's a new file in this branch
  - conversationHistory sent to /api/reader-chat is built from Zustand messages (excluding the streaming placeholder)
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-015
- What was implemented:
  - Executive evaluation right panel component at src/components/scout/executive-eval-panel.tsx
  - ExecutiveStreamState type added to src/lib/agent-sdk/types.ts (status, verdict, confidence, rationale, keyFactors, concerns)
  - executive_start and executive_complete SSE event types added to ScoutEventType union
  - executiveId and executiveName fields added to ScoutSSEEvent for executive routing
  - onExecutiveStart and onExecutiveComplete callbacks added to EventRouterCallbacks
  - Event router executive case updated to parse executive_start/executive_complete events
  - executiveStates Map added to Zustand store (ScoutSessionState) with setExecutiveState/clearExecutiveStates actions
  - scout-chat.tsx wired with executive callbacks (setExecutiveState on start/complete)
  - focus-group-panel.tsx updated with no-op executive callbacks for type conformance
  - ScoutLayout updated to render ExecutiveEvalPanel instead of placeholder text
  - Panel shows: executives list with loading spinners (evaluating), verdict badge (PURSUE green / PASS red), confidence %, rationale, key factors, concerns
  - Results accumulate as each executive completes, persisted in Zustand Map
- Files changed:
  - src/lib/agent-sdk/types.ts (modified — added ExecutiveStreamState, executive_start/complete event types, executiveId/executiveName on SSE event)
  - src/lib/agent-sdk/event-router.ts (modified — added executive callbacks, updated executive case routing)
  - src/stores/app-store.ts (modified — added executiveStates Map, setExecutiveState, clearExecutiveStates)
  - src/components/scout/scout-chat.tsx (modified — added setExecutiveState destructure, executive callbacks, dependency array)
  - src/components/scout/focus-group-panel.tsx (modified — added onExecutiveStart/onExecutiveComplete no-ops)
  - src/components/scout/scout-layout.tsx (modified — import ExecutiveEvalPanel, replace placeholder)
  - src/components/scout/executive-eval-panel.tsx (new — full executive eval panel component)
- **Learnings for future iterations:**
  - When adding new callbacks to EventRouterCallbacks, also update focus-group-panel.tsx which has its own inline callbacks object for follow-up messages
  - ExecutiveStreamState uses Map<string, ExecutiveStreamState> (like readerStates) — not a flat array, so entries accumulate and persist across panel switches
  - Pre-existing type errors in agent-sdk/tools/ and api/reader-chat/ are NOT caused by new changes — they're pre-existing Prisma JSON type issues
  - The event router 'executive' case previously only called onPhaseChange — now it also handles executive_start/executive_complete sub-events
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-016
- What was implemented:
  - GET /api/drafts/[id]/deliverable — returns DraftDeliverable with all JSON fields (harmonizedCoverage, harmonizedScores, readerPerspectives, scoutAnalysis, studioCalibration)
  - Returns 404 if no deliverable exists for the draft
  - GET /api/drafts/[id]/focus-sessions — returns FocusSessions with messages, ordered by createdAt desc
  - Each focus session includes messages ordered by sequenceNumber asc
  - Both routes validate auth via getCurrentUser() — return 401 if unauthenticated
  - Both routes verify draft belongs to user's studio via project.studioId check — return 404 for access violations
  - Both routes return 404 for non-existent draft IDs
- Files changed:
  - src/app/api/drafts/[id]/deliverable/route.ts (new)
  - src/app/api/drafts/[id]/focus-sessions/route.ts (new)
- **Learnings for future iterations:**
  - Draft access control pattern: findUnique draft with `include: { project: { select: { studioId: true } } }`, then check `draft.project.studioId !== user.studioId`
  - DraftDeliverable has a unique constraint on draftId — use `findUnique({ where: { draftId: id } })` not `findFirst`
  - FocusSession messages should be ordered by sequenceNumber (not createdAt) for correct conversation ordering
  - Pre-existing type errors in agent-sdk/tools/ are known and don't block new API routes (ignoreBuildErrors: true)
---

## 2026-01-22 - US-017
- What was implemented:
  - GET /api/drafts/[id]/evaluations — returns ExecutiveEvaluations with executive profile data included, ordered by createdAt desc
  - GET /api/studio — returns current user's Studio with _count of readerPersonas and projects
  - PUT /api/studio — accepts { name } and updates the studio record (validates name is non-empty string)
  - GET /api/studio/readers — returns ReaderPersonas for the user's studio, ordered by createdAt asc
  - PUT /api/studio/readers/[id] — accepts persona fields and updates the record (validates ownership)
  - GET /api/studio/executives — returns ExecutiveProfiles for the user's studio, ordered by createdAt asc
  - PUT /api/studio/executives/[id] — accepts profile fields and updates the record (validates ownership)
  - GET /api/studio/intelligence — returns StudioIntelligence for the user's studio (404 if not found)
  - All routes validate auth via getCurrentUser() — return 401 if unauthenticated
  - PUT routes verify entity belongs to user's studio before allowing updates
- Files changed:
  - src/app/api/drafts/[id]/evaluations/route.ts (new)
  - src/app/api/studio/route.ts (new)
  - src/app/api/studio/readers/route.ts (new)
  - src/app/api/studio/readers/[id]/route.ts (new)
  - src/app/api/studio/executives/route.ts (new)
  - src/app/api/studio/executives/[id]/route.ts (new)
  - src/app/api/studio/intelligence/route.ts (new)
- **Learnings for future iterations:**
  - Studio entity access control: reader/executive entities have `studioId` field — check `entity.studioId !== user.studioId` directly (no need for project relation join)
  - PUT routes use conditional spread for optional fields: `...(body.field !== undefined && { field: body.field })` — allows partial updates without overwriting unset fields
  - Studio GET uses `_count: { select: { readerPersonas: true, projects: true } }` for relation counts
  - ExecutiveEvaluation includes `executive: true` in the findMany to get profile data inline
  - StudioIntelligence has unique constraint on studioId — use `findUnique({ where: { studioId } })`
---

## 2026-01-22 - US-018
- What was implemented:
  - useDrafts(projectId) hook fetches drafts from project detail endpoint, staleTime 30s
  - draftKeys query key factory exported from use-drafts.ts for cache invalidation (list, deliverable, focusSessions, evaluations)
  - useDeliverable(draftId) hook fetches GET /api/drafts/[id]/deliverable, staleTime 5min, returns null for 404
  - useFocusSessions(draftId) hook fetches GET /api/drafts/[id]/focus-sessions, staleTime 30s
  - useEvaluations(draftId) hook fetches GET /api/drafts/[id]/evaluations, staleTime 30s
  - useStudio() hook fetches GET /api/studio, staleTime 10min
  - useReaderPersonas() hook fetches GET /api/studio/readers, staleTime 30s
  - useExecutiveProfiles() hook fetches GET /api/studio/executives, staleTime 30s
  - useStudioIntelligence() hook fetches GET /api/studio/intelligence, staleTime 10min, returns null for 404
  - All hooks return { data, isLoading, error } and handle undefined/null gracefully via `enabled` guard
  - Response types defined for all API shapes (DeliverableResponse, FocusSessionResponse, EvaluationResponse, StudioResponse, ReaderPersonaResponse, ExecutiveProfileData, StudioIntelligenceResponse)
- Files changed:
  - src/hooks/use-drafts.ts (modified — added useDrafts hook and draftKeys factory)
  - src/hooks/use-studio.ts (new — useDeliverable, useFocusSessions, useEvaluations, useStudio, useReaderPersonas, useExecutiveProfiles, useStudioIntelligence)
- **Learnings for future iterations:**
  - draftKeys pattern: `list: (projectId) => ['drafts', projectId]`, `deliverable: (draftId) => ['drafts', draftId, 'deliverable']` etc. — use these for cache invalidation in mutations
  - useDeliverable and useStudioIntelligence return null (not throw) for 404 responses — components should check `data === null` for empty state
  - useDrafts fetches from the project detail endpoint (GET /api/projects/[id]) and extracts `.drafts` array — reuses existing route rather than a separate drafts list endpoint
  - studioKeys exported from use-studio.ts for external cache invalidation (e.g., after PUT updates in studio configuration views)
  - Browser verification not available — manual testing needed
---
