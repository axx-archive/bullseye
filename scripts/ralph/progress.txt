# Ralph Progress Log
Started: Fri Jan 23 18:07:41 PST 2026

## Codebase Patterns
- In scout-chat.tsx, use refs (useRef + useEffect to sync) instead of including unstable callbacks in useEffect dependency arrays
- Run `npm run lint -- <filepath>` to lint specific files; `npx tsc --noEmit` for typecheck
- The eslint rule `react-hooks/refs` forbids assigning ref.current during render — wrap in useEffect instead
- handleSendMessage has chatMessages in its useCallback deps, making it unstable — always access via ref for effects
- Scout system prompt is in src/lib/agent-sdk/prompts.ts — FILE UPLOADS section and AUTONOMOUS WORKFLOW must stay consistent
- Turn boundaries in Agent SDK streaming: use a turnCompleteRef flag set on text_complete and checked on next text_delta to create new assistant messages
- When creating new assistant messages mid-stream, also reset streamingTextRef and toolCallsRef so subsequent content is independent
- onResult/onError should use currentAssistantIdRef.current (not captured assistantId) since the active message may have changed during multi-turn
- Chat persistence uses ChatSession (1:1 with Project via unique projectId) and ChatSessionMessage (many per session, ordered by createdAt)
- Prisma client is generated to `src/generated/prisma` — import types from there

---

## 2026-01-23 - US-001
- What was implemented: Fixed pendingScoutAttachment double-fire by adding a processingRef guard and using a handleSendMessageRef to avoid including the unstable handleSendMessage in the useEffect dependency array
- Files changed: src/components/scout/scout-chat.tsx
- **Learnings for future iterations:**
  - handleSendMessage depends on chatMessages via useCallback, so it changes on every message — never use it directly as a useEffect dep for effects that should fire once
  - The eslint react-hooks/refs rule disallows ref.current assignment during render — use a syncing useEffect instead
  - The processingRef pattern (set true before action, false after) prevents React StrictMode or fast state changes from re-triggering effects
---

## 2026-01-23 - US-002
- What was implemented: Fixed the AUTONOMOUS WORKFLOW step 3 (Ingest) in the Scout system prompt to be conditional — it now instructs Scout to skip ingest_script when a file was uploaded (indicated by "[UPLOADED SCRIPT FILE: ...]" marker) and only call it for pasted script text. This resolves the contradiction with the FILE UPLOADS section.
- Files changed: src/lib/agent-sdk/prompts.ts
- **Learnings for future iterations:**
  - The Scout system prompt is in src/lib/agent-sdk/prompts.ts as a single template literal export
  - The FILE UPLOADS section and AUTONOMOUS WORKFLOW section must stay consistent — if one says "don't call X", the workflow steps must reflect that
  - The "[UPLOADED SCRIPT FILE: ...]" marker in user messages is the signal that pre-ingestion happened
---

## 2026-01-23 - US-003
- What was implemented: Fixed multi-turn text concatenation by adding turn boundary detection. When `text_complete` fires, `turnCompleteRef` is set to true. When the next `text_delta` arrives and `turnCompleteRef` is true, a new assistant message placeholder is created with a fresh UUID, and `streamingTextRef` is reset. This ensures each Agent SDK turn renders as its own distinct chat message.
- Files changed: src/components/scout/scout-chat.tsx
- **Learnings for future iterations:**
  - The Agent SDK sends: text_delta → text_complete → (tool calls) → text_delta → text_complete for multi-turn flows
  - Turn boundary detection pattern: set a flag on text_complete, check it on next text_delta, create new message if flag is set
  - When starting a new turn mid-stream, reset streamingTextRef, toolCallsRef, and update currentAssistantIdRef to the new message
  - onResult and onError must reference currentAssistantIdRef.current (dynamic) rather than the initially captured assistantId, since multi-turn creates new messages
---

## 2026-01-23 - US-004
- What was implemented: Added ChatSession and ChatSessionMessage Prisma models for project-scoped chat persistence. ChatSession has a unique projectId constraint (one session per project). ChatSessionMessage stores role, content, agentType, toolCalls (JSON), attachmentName, and attachmentSize. Added cascade delete and Project → ChatSession optional relation. Ran migration successfully.
- Files changed: prisma/schema.prisma, prisma/migrations/20260124021455_add_chat_session_models/migration.sql
- **Learnings for future iterations:**
  - Prisma migration command: `npx prisma migrate dev --name <name>` — generates SQL and applies it
  - After migration, run `npx prisma generate` to regenerate the client with new model types
  - The existing ChatMessage model (line 494) is a simpler legacy model — the new ChatSession/ChatSessionMessage models are the proper project-scoped persistence layer
  - Use `@unique` on projectId in ChatSession to enforce one session per project at the DB level
  - Use `@@index([sessionId, createdAt])` on ChatSessionMessage for efficient ordered retrieval
---
