# Ralph Progress Log
Started: Fri Jan 23 18:07:41 PST 2026

## Codebase Patterns
- In scout-chat.tsx, use refs (useRef + useEffect to sync) instead of including unstable callbacks in useEffect dependency arrays
- Run `npm run lint -- <filepath>` to lint specific files; `npx tsc --noEmit` for typecheck
- The eslint rule `react-hooks/refs` forbids assigning ref.current during render — wrap in useEffect instead
- handleSendMessage has chatMessages in its useCallback deps, making it unstable — always access via ref for effects
- Scout system prompt is in src/lib/agent-sdk/prompts.ts — FILE UPLOADS section and AUTONOMOUS WORKFLOW must stay consistent
- Turn boundaries in Agent SDK streaming: use a turnCompleteRef flag set on text_complete and checked on next text_delta to create new assistant messages
- When creating new assistant messages mid-stream, also reset streamingTextRef and toolCallsRef so subsequent content is independent
- onResult/onError should use currentAssistantIdRef.current (not captured assistantId) since the active message may have changed during multi-turn
- The eslint rule `react-hooks/set-state-in-effect` disallows synchronous setState in effect bodies — extract an async function and call it instead
- Chat persistence uses ChatSession (1:1 with Project via unique projectId) and ChatSessionMessage (many per session, ordered by createdAt)
- Fire-and-forget persistence pattern: use a top-level `persistChatMessage(projectId, data)` helper that wraps fetch().catch(console.error)
- Prisma client is generated to `src/generated/prisma` — import types from there

---

## 2026-01-23 - US-001
- What was implemented: Fixed pendingScoutAttachment double-fire by adding a processingRef guard and using a handleSendMessageRef to avoid including the unstable handleSendMessage in the useEffect dependency array
- Files changed: src/components/scout/scout-chat.tsx
- **Learnings for future iterations:**
  - handleSendMessage depends on chatMessages via useCallback, so it changes on every message — never use it directly as a useEffect dep for effects that should fire once
  - The eslint react-hooks/refs rule disallows ref.current assignment during render — use a syncing useEffect instead
  - The processingRef pattern (set true before action, false after) prevents React StrictMode or fast state changes from re-triggering effects
---

## 2026-01-23 - US-002
- What was implemented: Fixed the AUTONOMOUS WORKFLOW step 3 (Ingest) in the Scout system prompt to be conditional — it now instructs Scout to skip ingest_script when a file was uploaded (indicated by "[UPLOADED SCRIPT FILE: ...]" marker) and only call it for pasted script text. This resolves the contradiction with the FILE UPLOADS section.
- Files changed: src/lib/agent-sdk/prompts.ts
- **Learnings for future iterations:**
  - The Scout system prompt is in src/lib/agent-sdk/prompts.ts as a single template literal export
  - The FILE UPLOADS section and AUTONOMOUS WORKFLOW section must stay consistent — if one says "don't call X", the workflow steps must reflect that
  - The "[UPLOADED SCRIPT FILE: ...]" marker in user messages is the signal that pre-ingestion happened
---

## 2026-01-23 - US-003
- What was implemented: Fixed multi-turn text concatenation by adding turn boundary detection. When `text_complete` fires, `turnCompleteRef` is set to true. When the next `text_delta` arrives and `turnCompleteRef` is true, a new assistant message placeholder is created with a fresh UUID, and `streamingTextRef` is reset. This ensures each Agent SDK turn renders as its own distinct chat message.
- Files changed: src/components/scout/scout-chat.tsx
- **Learnings for future iterations:**
  - The Agent SDK sends: text_delta → text_complete → (tool calls) → text_delta → text_complete for multi-turn flows
  - Turn boundary detection pattern: set a flag on text_complete, check it on next text_delta, create new message if flag is set
  - When starting a new turn mid-stream, reset streamingTextRef, toolCallsRef, and update currentAssistantIdRef to the new message
  - onResult and onError must reference currentAssistantIdRef.current (dynamic) rather than the initially captured assistantId, since multi-turn creates new messages
---

## 2026-01-23 - US-004
- What was implemented: Added ChatSession and ChatSessionMessage Prisma models for project-scoped chat persistence. ChatSession has a unique projectId constraint (one session per project). ChatSessionMessage stores role, content, agentType, toolCalls (JSON), attachmentName, and attachmentSize. Added cascade delete and Project → ChatSession optional relation. Ran migration successfully.
- Files changed: prisma/schema.prisma, prisma/migrations/20260124021455_add_chat_session_models/migration.sql
- **Learnings for future iterations:**
  - Prisma migration command: `npx prisma migrate dev --name <name>` — generates SQL and applies it
  - After migration, run `npx prisma generate` to regenerate the client with new model types
  - The existing ChatMessage model (line 494) is a simpler legacy model — the new ChatSession/ChatSessionMessage models are the proper project-scoped persistence layer
  - Use `@unique` on projectId in ChatSession to enforce one session per project at the DB level
  - Use `@@index([sessionId, createdAt])` on ChatSessionMessage for efficient ordered retrieval
---

## 2026-01-23 - US-005
- What was implemented: Created POST and GET /api/projects/[id]/chat API endpoints for chat persistence. GET loads all messages for a project's chat session ordered by createdAt. POST upserts the ChatSession (creates on first message) and creates a ChatSessionMessage. Both endpoints verify user authentication and project ownership via studioId matching.
- Files changed: src/app/api/projects/[id]/chat/route.ts (new file)
- **Learnings for future iterations:**
  - The project route pattern uses `params: Promise<{ id: string }>` (Next.js 15 async params) — always await params
  - Use `db.chatSession.upsert` with `where: { projectId }` to atomically create-or-update the session on first message
  - Project ownership check: fetch project, compare project.studioId to user.studioId
  - Return 404 (not 403) for projects the user doesn't own — avoids leaking project existence
  - The select clause on message queries should match the GET response shape for consistency
---

## 2026-01-23 - US-006
- What was implemented: Added fire-and-forget chat message persistence in scout-chat.tsx. User messages are persisted after being added to the store. Assistant turn content is persisted on onScoutTextComplete. On onResult, the final assistant state with toolCalls is persisted (only if toolCalls exist, since text was already saved by onScoutTextComplete). All persistence calls are guarded by a currentProject?.id check and wrapped in .catch(console.error).
- Files changed: src/components/scout/scout-chat.tsx
- **Learnings for future iterations:**
  - Use a top-level helper function (outside the component) for fire-and-forget persistence to keep callback bodies clean
  - Be careful about duplicate persistence: onScoutTextComplete fires per turn AND onResult fires at the end — only persist from onResult if there's additional data (toolCalls) beyond what onScoutTextComplete already saved
  - useAppStore.getState().currentProject?.id is the way to access projectId from inside callbacks without adding it as a dependency
  - The persistChatMessage helper uses fetch().catch(console.error) pattern — non-blocking, silent failure by design
---

## 2026-01-23 - US-007
- What was implemented: Added a useEffect in ScoutChat that watches currentProject changes. When the project changes, it clears chatMessages via clearChat(), then fetches GET /api/projects/[id]/chat. DB messages are mapped to StoreChatMessage format and populated into the store. A loading indicator shows while fetching. A prevProjectIdRef prevents redundant fetches when the same project re-renders.
- Files changed: src/components/scout/scout-chat.tsx
- **Learnings for future iterations:**
  - The eslint rule `react-hooks/set-state-in-effect` disallows synchronous setState calls in effect bodies — wrap in an async IIFE or extracted async function to satisfy it
  - Use prevProjectIdRef pattern to deduplicate effect runs when the dependency (currentProject object) changes identity but the ID stays the same
  - The GET /api/projects/[id]/chat response shape: { messages: Array<{ id, role, content, agentType, toolCalls, attachmentName, attachmentSize, createdAt }> }
  - Map DB `agentType` (nullable string) to StoreChatMessage `agentType` (optional 'SCOUT'|'READER') with nullish coalescing to undefined
  - Use `useAppStore.setState({ chatMessages: mapped })` for bulk-setting messages (same pattern as retry handler)
---
