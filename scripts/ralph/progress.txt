# Ralph Progress Log
Started: Sat Jan 24 07:57:21 PST 2026
---

## Codebase Patterns
- For loading/skeleton UI in components with hooks: place the early return AFTER all hook calls (React rules-of-hooks) — check the condition but render skeleton conditionally after hooks
- The ScoutChat component uses `useAppStore` (Zustand) for all SCOUT state (chatMessages, readerStates, rightPanelMode, etc.)
- Chat history is loaded via `GET /api/projects/{id}/chat` and persisted via `POST /api/projects/{id}/chat`
- SSE connections are managed via `createSSEConnection` from `@/lib/agent-sdk/event-router`
- `pendingScoutAttachment` in Zustand is set by the upload flow to trigger auto-analysis after a draft upload
- `handleSendMessageRef` pattern is used to avoid stale closures in effects
- `processingAttachmentRef` prevents double-firing of the attachment effect
- TypeScript typecheck: `npx tsc --noEmit`; lint: `npx eslint <file>`
- The project is a Next.js app with Prisma ORM
- The generated Prisma client (`src/generated/prisma/`) is gitignored — only commit schema.prisma and migration files
- `ReaderAnalysisState` is the "hot" state for UI rendering (in-progress analysis); `ReaderMemory` is the "cold" state for cross-draft context injection
- Use `@@unique([draftId, readerId])` pattern for one-state-per-reader-per-draft constraints
- SSE callback phases: attachment send → 'processing', onToolStart → 'analyzing', onReaderStart → 'engaging', onScoutTextDelta → clears init phase
- The `ScoutInitProgress` component renders a stepped phase indicator with stale timeout (10s) support
- API routes use `params: Promise<{ id: string }>` (awaited inside handler) and `NextRequest`/`NextResponse` from next/server
- "Latest draft" is always found via `db.draft.findFirst({ where: { projectId }, orderBy: { draftNumber: 'desc' } })`
- SCOUT state endpoint: `GET /api/projects/[id]/scout-state` returns `{ readerStates, focusGroupMessages, executiveEvals, scoutPhase }`
- Prisma nullable JSON fields require `Prisma.JsonNull` sentinel (not literal `null`) — import from `@/generated/prisma/client`
- Compound unique keys in Prisma upsert: `where: { draftId_readerId: { draftId, readerId } }`
- Debounced persistence pattern: use a ref for the timer, `useCallback` for the flush function, read Zustand state via `getState()` to avoid stale closures, flush immediately on "complete" events
- Zustand store uses `(set, get)` — use `get()` inside actions to access current state (e.g., `get().currentProject?.id`) for fire-and-forget side-effects
- For fire-and-forget DB persistence from Zustand actions, use `fetch().catch(console.error)` — no async/await needed

---

## 2026-01-24 - US-001
- **What was implemented**: Fixed the race condition between chat history loading and pendingScoutAttachment auto-send
- **Files changed**: `src/components/scout/scout-chat.tsx`
- **Fix details**:
  - Added `isHistoryLoaded` state (initially `false`)
  - History loading effect sets `isHistoryLoaded = false` when project changes, then `true` after fetch completes (or immediately if no project)
  - Attachment auto-send effect now checks `isHistoryLoaded` before firing, preventing it from triggering while `clearChat()` or history fetch is in progress
  - Added `isHistoryLoaded` to the attachment effect's dependency array so it re-evaluates once history is ready
- **Learnings for future iterations:**
  - The two key effects in scout-chat.tsx that must coordinate: (1) history loader (watches `currentProject`) and (2) attachment sender (watches `pendingScoutAttachment`)
  - `clearChat()` is called on every project change — any effect that sends messages must wait for it to complete
  - For new projects with no history, the fetch returns an empty array quickly, so the `isHistoryLoaded` flag flips fast
  - The existing `processingAttachmentRef` prevents double-sends but does NOT prevent sends during loading — the new `isHistoryLoaded` state handles that
---

## 2026-01-24 - US-002
- **What was implemented**: Added stepped progress indicators for SCOUT initialization
- **Files changed**: `src/components/scout/scout-chat.tsx`
- **Implementation details**:
  - Added `ScoutInitPhase` type: `'idle' | 'processing' | 'analyzing' | 'engaging' | 'error'`
  - Created `ScoutInitProgress` component with stepped dots + labels showing phase progression
  - Added `scoutInitPhase`, `initStaleMessage`, `initErrorMessage` state to ScoutChat
  - Init phase transitions: attachment send → 'processing', onToolStart → 'analyzing', onReaderStart → 'engaging'
  - `clearInitPhase()` called on `onScoutTextDelta` (content arrives) and `onResult` (stream ends)
  - 10-second stale timer shows "Still working..." if phase doesn't advance
  - Error phase shows error message + Retry button
  - Progress indicator replaces the "Loading conversation" spinner and chat interface during initialization
- **Learnings for future iterations:**
  - The init phase is only triggered when sending with an attachment (script upload flow) — regular messages don't show the progress indicator
  - `scoutInitPhase` is read inside `sendMessageToScout` callbacks which means it's captured at callback creation time — the dependency array must include it
  - The `clearInitPhase` function handles both timer cleanup and state reset — always use it instead of just setting phase to 'idle'
  - The progress indicator replaces the ChatInterface entirely during init (not an overlay) to avoid confusing partial UI
---

## 2026-01-24 - US-003
- **What was implemented**: Added `ReaderAnalysisState` database model for persisting per-reader analysis state
- **Files changed**: `prisma/schema.prisma`, `prisma/migrations/20260124160446_add_reader_analysis_state/migration.sql`
- **Implementation details**:
  - Added `ReaderAnalysisState` model with fields: id, draftId, readerId, status (pending|streaming|complete|error), progress (0-100), scores (Json?), recommendation, keyStrengths, keyConcerns, standoutQuote, error, createdAt, updatedAt
  - Added `@@unique([draftId, readerId])` constraint for one state per reader per draft
  - Added cascade delete relation from Draft → ReaderAnalysisState
  - Added `readerAnalysisStates` relation field on the Draft model
  - Migration applied successfully to production database
- **Learnings for future iterations:**
  - The generated Prisma client is in `src/generated/prisma/` and is gitignored — never try to `git add` it
  - Run `npx prisma generate` after migration to regenerate the client for typecheck
  - The model uses String for `status` (not an enum) to allow flexibility from the client side — the values are validated at the application layer
  - `readerId` is a String (not a relation) because it references the ReaderPersona ID but doesn't need a full FK constraint — readers may be reconfigured independently
---

## 2026-01-24 - US-004
- **What was implemented**: Added `scoutPhase` field to the `ChatSession` model for persisting the right panel's current phase
- **Files changed**: `prisma/schema.prisma`, `prisma/migrations/20260124160634_add_scout_phase_to_chat_session/migration.sql`
- **Implementation details**:
  - Added `scoutPhase String?` field to `ChatSession` model (nullable, defaults to null)
  - Stores values: 'idle' | 'analysis' | 'focus_group' | 'reader_chat' | 'executive'
  - When null, client defaults to 'idle'
  - Migration adds a simple `TEXT` column to the existing `ChatSession` table
- **Learnings for future iterations:**
  - `ChatSession` has a `@unique` on `projectId` — one session per project, making it easy to look up by project ID
  - The `scoutPhase` field uses `String?` (not an enum) for flexibility — same pattern as `ReaderAnalysisState.status`
  - The `ChatSession` model already has `updatedAt @updatedAt` so any upsert will automatically track when phase was last changed
---

## 2026-01-24 - US-005
- **What was implemented**: Created GET `/api/projects/[id]/scout-state` endpoint that returns full SCOUT tab state for a project's current draft
- **Files changed**: `src/app/api/projects/[id]/scout-state/route.ts` (new file)
- **Implementation details**:
  - Authenticates user and verifies project ownership via `getCurrentUser()` + `studioId` check
  - Finds the latest draft by highest `draftNumber` for the project
  - Uses `Promise.all` for parallel DB queries: readerStates, focusSession (most recent with messages), executiveEvals, chatSession (for scoutPhase)
  - Returns empty arrays/null if no data exists (not 404)
  - Focus group messages come from the most recent `FocusSession` for the latest draft, ordered by `sequenceNumber`
  - Response shape: `{ readerStates, focusGroupMessages, executiveEvals, scoutPhase }`
- **Learnings for future iterations:**
  - The "latest draft" is determined by `orderBy: { draftNumber: 'desc' }` with `findFirst` — not by `createdAt`
  - `FocusSession` can have multiple per draft — always use the most recent one (`orderBy: { createdAt: 'desc' }`)
  - `ChatSession` has `@unique` on `projectId` so `findUnique({ where: { projectId } })` works directly
  - The route follows the same auth pattern as `/api/projects/[id]/chat`: `getCurrentUser()` → verify `studioId` match
  - Return shape uses flat arrays (not nested by draft) since the endpoint is always scoped to the latest draft
---

## 2026-01-24 - US-006
- **What was implemented**: Created PUT `/api/projects/[id]/scout-state` endpoint for persisting partial SCOUT state updates
- **Files changed**: `src/app/api/projects/[id]/scout-state/route.ts`
- **Implementation details**:
  - Added `PUT` handler to the existing route file alongside the `GET` handler
  - Accepts `{ readerStates?: Array<ReaderStateInput>, scoutPhase?: string | null }` in request body
  - For `readerStates`: finds latest draft, then uses `db.$transaction` with an array of `upsert` operations keyed by `draftId_readerId` compound unique
  - For `scoutPhase`: upserts the `ChatSession` record (since `projectId` is unique on ChatSession)
  - Auth pattern matches GET: `getCurrentUser()` → verify `studioId` match
  - Returns `{ success: true }` on success
- **Learnings for future iterations:**
  - Prisma nullable JSON fields require `Prisma.JsonNull` sentinel value (not literal `null`) — import `{ Prisma }` from `@/generated/prisma/client`
  - The `draftId_readerId` compound unique key is referenced in upsert's `where` clause as `{ draftId_readerId: { draftId, readerId } }`
  - For partial updates, use spread with conditional: `...(field !== undefined && { field: value })` — this avoids overwriting with undefined when a field isn't provided
  - `db.$transaction` accepts an array of Prisma operations for atomic multi-record updates
---

## 2026-01-24 - US-007
- **What was implemented**: Added debounced persistence of reader states to the database during SSE streaming
- **Files changed**: `src/components/scout/scout-chat.tsx`
- **Implementation details**:
  - Added `persistReaderDebounceRef` to hold the debounce timer
  - Created `flushReaderStates` callback that reads current `readerStates` from the Zustand store and sends them to `PUT /api/projects/[id]/scout-state`
  - Created `debouncedPersistReaderStates` callback that debounces calls to `flushReaderStates` by 500ms
  - `onReaderStart` and `onReaderProgress` callbacks trigger the debounced version
  - `onReaderComplete` calls `flushReaderStates` directly (bypasses debounce) to ensure final state is persisted immediately
  - All persist calls are fire-and-forget — failures are caught and logged to console
  - Only fires if `currentProject?.id` is available (checked via `useAppStore.getState()`)
  - Debounce timer is cleaned up on unmount alongside the init stale timer
- **Learnings for future iterations:**
  - Reading Zustand state directly via `useAppStore.getState()` inside callbacks avoids stale closure issues — no need to pass readerStates as a dependency
  - The debounce pattern uses a ref (not state) because we don't want re-renders when the timer changes
  - `flushReaderStates` reads the full Map and converts to array before sending — the PUT endpoint expects an array of reader state objects
  - The `setReaderState` call in onReaderComplete sets the store state synchronously, so the subsequent `flushReaderStates()` call will pick up the updated state
---

## 2026-01-24 - US-008
- **What was implemented**: Added database persistence of `scoutPhase` whenever the right panel mode changes
- **Files changed**: `src/stores/app-store.ts`
- **Implementation details**:
  - Modified `setRightPanelMode` action from a simple setter to include a fire-and-forget PUT request to `/api/projects/[id]/scout-state`
  - Uses `get()` (previously `_get`) to access `currentProject.id` from within the Zustand action
  - Only fires the request if `currentProject?.id` is available
  - Sends `null` for 'idle' mode (since null means idle on the server side), sends the mode string for all other phases
  - Failures are caught and logged to console without interrupting the UI
- **Learnings for future iterations:**
  - The Zustand store creator has `(set, get)` — `get()` provides access to current state inside actions without needing closures or subscriptions
  - For fire-and-forget persistence from Zustand actions, use `fetch().catch()` pattern — no need for async/await since we don't depend on the result
  - The PUT `/api/projects/[id]/scout-state` endpoint accepts partial updates — sending just `{ scoutPhase }` without `readerStates` is valid
  - 'idle' maps to `null` in the database — avoid persisting the literal string 'idle' since the schema uses null to mean idle
---

## 2026-01-24 - US-009
- **What was implemented**: Hydrate SCOUT tab state from database on mount — readers, focus group, executives, and panel phase are all restored when returning to the SCOUT tab
- **Files changed**: `src/components/scout/scout-chat.tsx`, `src/stores/app-store.ts`, `src/components/scout/reader-analysis-panel.tsx`, `src/components/scout/focus-group-panel.tsx`, `src/components/scout/executive-eval-panel.tsx`
- **Implementation details**:
  - Added `isHydratingScoutState` boolean to Zustand store (not persisted) with `setHydratingScoutState` action
  - Added hydration effect in `scout-chat.tsx` that fetches `GET /api/projects/[id]/scout-state` when `currentProject` changes (runs in parallel with existing chat history fetch)
  - Populates `readerStates` Map, `focusGroupMessages` array, `executiveStates` Map, and `rightPanelMode` from the API response
  - Reconciliation: DB wins if local store has no data; if local already has data (e.g., from SSE streaming), it is preserved
  - Added per-section loading skeletons to `ReaderAnalysisPanel`, `FocusGroupPanel`, and `ExecutiveEvalPanel` — each shows its own skeleton when `isHydratingScoutState` is true and local data is empty
  - Skeletons show 3 reader cards (analysis), 4 message bubbles (focus group), and 3 executive cards with animated pulse effects
  - Focus group hydration maps DB records to `FocusGroupUIMessage` format including reader names/colors from READER_NAMES/READER_COLORS maps
  - Executive hydration maps DB records to `ExecutiveStreamState` with status 'complete'
  - The `FocusGroupPanel` skeleton check is placed after all hooks to avoid `react-hooks/rules-of-hooks` violations
- **Learnings for future iterations:**
  - Early returns for skeleton/loading UI in React components must be placed AFTER all hook calls to satisfy rules-of-hooks lint rule
  - The `isHydratingScoutState` flag is set to true before the fetch starts and false in finally — this ensures panels show skeletons even during failed fetches
  - DB responses for focus group messages use `speakerType` and `readerId` — must map these to `speaker` (display name) and `readerColor` for the UI type
  - The hydration effect uses `useAppStore.getState()` for reading current state to avoid stale closures, and `useAppStore.setState()` for batch updates
  - Executive evaluations from DB don't include `executiveName` — the display name comes from the executive config (left as executiveId, overridden by component)
---
