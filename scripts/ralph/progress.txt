# Ralph Progress Log
Started: Thu Jan 22 16:30:42 PST 2026

## Codebase Patterns
- Prisma 7 uses `prisma.config.ts` for database URLs — NOT `url`/`directUrl` in schema.prisma datasource block
- Prisma 7 CLI flags changed: use `--to-schema` instead of `--to-schema-datamodel`, use `-o` for output file
- db.ts uses PrismaClient with PrismaPg adapter (pg Pool) — standard Prisma 7 adapter pattern
- Studio and User have circular FK dependency — use pg pool with `SET CONSTRAINTS ALL DEFERRED` for seeding
- Seed script uses `tsx` to run TypeScript directly — added as dev dependency
- Pre-existing type errors exist in agent-sdk tools — `next.config.ts` has `ignoreBuildErrors: true`
- db.ts exports `db` (named) and `default` — use `import { db } from '@/lib/db'` in routes
- Default studio ID is `'default-studio-id'` — use this constant for user provisioning
- User provisioning happens at 3 points: login page fetch, auth callback server-side, and getCurrentUser() fallback in auth.ts
- `.env*` is gitignored — `.env.example` is exempted with `!.env.example`
- Generated Prisma client outputs to `src/generated/prisma` — imported as `@/generated/prisma/client`
- Toast store is a separate Zustand store at `src/stores/toast-store.ts` — use `useToastStore` with `addToast(message, variant)`
- ToastContainer is rendered in `src/app/providers.tsx` — no need to add it per-page
- Design system has semantic color vars: `--success`, `--warning`, `--danger`, `--info` — use as Tailwind classes `bg-success`, `text-danger`, etc.
- React Query hooks go in `src/hooks/` — export query key factories (e.g., `projectKeys`) for external invalidation
- React Query v5 useMutation needs 4th generic `TContext` for typed optimistic update rollback
- API routes use `getCurrentUser()` from `@/lib/auth` — returns null if unauthed, user includes `studioId` for scoping
- Next.js 15 dynamic route params are a Promise — use `const { id } = await params` (type: `{ params: Promise<{ id: string }> }`)
- Access control: always check `project.studioId !== user.studioId` to prevent cross-studio access
- Home view no longer uses Zustand `projects` array — uses `useProjects()` React Query hook, which returns `ProjectWithCount[]` with `_count.drafts`
- Project creation uses `useCreateProject` mutation — onSuccess sets Zustand state and navigates, onError shows toast
- Supabase admin client at `src/lib/supabase/admin.ts` — uses service role key for server-side storage/RLS bypass
- Draft upload route auto-increments `draftNumber` by querying latest draft for the project
- PDF extraction returns both `text` and `pageCount` — Draft model stores both
- Draft hooks go in `src/hooks/use-drafts.ts` — useUploadDraft sends FormData, invalidates projectKeys on success
- DraftStatus type: 'PENDING' | 'ANALYZING' | 'COMPLETED' | 'FAILED' — use these exact values
- Scout chat messages stored in Zustand `chatMessages` (not local state) — persists across tab switches but not page refreshes
- `updateChatMessage(id, updates)` in app-store for targeted message updates during streaming
- SSE connection via `createSSEConnection(url, body, callbacks)` from `@/lib/agent-sdk/event-router`
- StoreChatMessage type exported from app-store — matches ChatMessage from chat-interface.tsx (timestamp optional)
- Tool status pills are tracked via `toolCalls: ToolCallStatus[]` on the assistant message — updated via `updateChatMessage(id, { toolCalls })` during streaming
- MCP tool names prefixed with `mcp__bullseye-tools__` — strip with `tool.split('__').pop()` to get the base name for TOOL_DISPLAY_NAMES lookup
- Event router auto-switches rightPanelMode based on SSE source — reader sources → 'analysis', focus_group → 'focus_group', reader_chat/executive → their respective modes
- Phase change guard in scout-chat's onPhaseChange callback prevents redundant mode switches and side effects (check `useAppStore.getState().rightPanelMode !== phase` before acting)
- Reader chat messages stored in Zustand `readerChatMessages` (Record<string, ReaderChatMessage[]>) — keyed by readerId, persists across panel switches
- `addReaderChatMessage(readerId, msg)` and `updateReaderChatMessage(readerId, msgId, updates)` for per-reader message management
- Executive streaming states stored in Zustand `executiveStates` Map<string, ExecutiveStreamState> — accumulates results, persists across panel switches
- When adding new EventRouterCallbacks, also update focus-group-panel.tsx (has its own inline callbacks for follow-up messages)
- Draft access control: `include: { project: { select: { studioId: true } } }` then check `draft.project.studioId !== user.studioId`
- DraftDeliverable has unique constraint on `draftId` — use `findUnique({ where: { draftId: id } })` not findFirst
- Studio sub-entity (readers/executives) access control: check `entity.studioId !== user.studioId` directly — no join needed
- StudioIntelligence has unique constraint on `studioId` — use `findUnique({ where: { studioId } })`
- PUT routes for partial updates: use conditional spread `...(body.field !== undefined && { field: body.field })` for each updatable field
- draftKeys exported from `src/hooks/use-drafts.ts` — use `draftKeys.deliverable(id)`, `draftKeys.evaluations(id)`, `draftKeys.focusSessions(id)` for cache invalidation
- studioKeys exported from `src/hooks/use-studio.ts` — use `studioKeys.studio`, `studioKeys.readers`, `studioKeys.executives`, `studioKeys.intelligence` for cache invalidation
- Hooks that fetch optional data (deliverable, intelligence) return `null` for 404 — check `data === null` for empty state, not just `!data` (which also matches loading)
- Mobile responsive pattern: `hidden md:flex` hides desktop nav, bottom tab bar uses `fixed bottom-0` with `safe-area-bottom` utility
- Modal bottom-sheet on mobile: `items-end md:items-center` + `rounded-t-2xl md:rounded-2xl` + `md:max-w-{size} md:mx-4`
- Reader cards use `lg:grid-cols-3` (1024px+ breakpoint) for tablet single-column stacking, not `md:grid-cols-3`
- Content padding pattern: `px-4 md:px-8` for all main content areas to ensure readability at 375px
- ScoreIndicator hides rating text labels on mobile (hidden sm:inline) to prevent horizontal overflow

---

## 2026-01-22 - US-001
- What was implemented:
  - Prisma migration (0001_init) generated from schema and marked as applied
  - prisma.config.ts updated with DIRECT_URL fallback for migrations
  - .env.example created with all required env vars
  - Seed script at scripts/seed.ts with Studio, 3 Readers, 5 Executives, StudioIntelligence
  - npm scripts: db:seed, db:migrate, db:generate
  - .gitignore updated to allow .env.example
  - tsx added as dev dependency
- Files changed:
  - .env.example (new)
  - .gitignore (modified)
  - prisma.config.ts (modified)
  - prisma/schema.prisma (modified — pre-existing changes included)
  - prisma/migrations/0001_init/migration.sql (new)
  - scripts/seed.ts (new)
  - package.json (modified)
  - package-lock.json (modified)
- **Learnings for future iterations:**
  - Prisma 7 removed `url` and `directUrl` from schema datasource block — must use prisma.config.ts
  - `prisma migrate diff` uses `--to-schema` flag (not `--to-schema-datamodel`)
  - Circular FK between Studio/User means you can't use Prisma ORM for initial insert — use raw pg pool with deferred constraints
  - The database already has tables from prior setup — use `prisma migrate resolve --applied` to baseline
  - tsx is needed as a dev dep to run seed.ts; npx tsx works but installs each time
---

## 2026-01-22 - US-002
- What was implemented:
  - User provisioning API route at src/app/api/auth/provision/route.ts
  - Login page updated to call /api/auth/provision after successful signInWithPassword
  - Auth callback updated to provision user server-side after exchangeCodeForSession
  - Fixed auth.ts type error — changed from nested studio create to studioId reference
  - auth.ts getCurrentUser() also provisions users as fallback
- Files changed:
  - src/app/api/auth/provision/route.ts (new)
  - src/app/auth/callback/route.ts (modified)
  - src/app/login/page.tsx (modified — added provision call)
  - src/lib/auth.ts (modified — fixed type error, use DEFAULT_STUDIO_ID)
- **Learnings for future iterations:**
  - db.ts exports as `{ db }` named export, not `{ prisma }`
  - The circular FK between Studio/User means you can't use nested `studio: { create: {} }` from User create — use studioId directly
  - auth.ts previously had a type error from trying to create Studio in nested User create — fixed by referencing default studio
  - Login page UI was already redesigned with Framer Motion animations in the working tree (pre-existing changes on branch)
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-003
- What was implemented:
  - Toast store at src/stores/toast-store.ts — Zustand store with addToast(message, variant) and removeToast(id)
  - Toast component at src/components/shared/toast.tsx — renders fixed bottom-right, stacks vertically with 8px gap
  - Supports 4 variants: success (green), error (red), warning (amber), info (blue) using design system color vars
  - Auto-dismisses after 5 seconds, also dismissible on click
  - Framer Motion AnimatePresence: enter (slide up + fade in + scale), exit (slide right + fade out)
  - Each toast has icon (CheckCircle, XCircle, AlertTriangle, Info from lucide-react)
  - ToastContainer added to providers.tsx so it renders on all pages
- Files changed:
  - src/stores/toast-store.ts (new)
  - src/components/shared/toast.tsx (new)
  - src/app/providers.tsx (modified — added ToastContainer import and render)
- **Learnings for future iterations:**
  - Toast store is intentionally separate from app-store — it's ephemeral UI state that shouldn't persist
  - Use `useToastStore.getState().addToast(msg, variant)` for non-component contexts (e.g., API error handlers)
  - Framer Motion `mode="popLayout"` is needed for smooth layout animations when toasts are removed from middle of stack
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-004
- What was implemented:
  - React Query hooks file at src/hooks/use-projects.ts
  - useProjects() hook: fetches GET /api/projects, returns ProjectWithCount[] (with _count.drafts), staleTime 30s
  - useProject(id) hook: fetches GET /api/projects/[id], returns ProjectWithDrafts (with drafts array), staleTime 30s, enabled only when id is truthy
  - useCreateProject() mutation: POST /api/projects, optimistic update (adds temp project to list immediately), rolls back on error, invalidates on settle
  - projectKeys query key factory exported for external cache invalidation
  - MutationContext type for proper onError context typing
  - QueryClientProvider was already set up in providers.tsx (from prior work)
- Files changed:
  - src/hooks/use-projects.ts (new)
- **Learnings for future iterations:**
  - QueryClientProvider is already in src/app/providers.tsx — no need to add it again
  - React Query v5 requires explicit 4th generic type param on useMutation for context typing (TData, TError, TVariables, TContext)
  - Project type in types/index.ts has optional `drafts?: Draft[]` — use Omit<Project, 'drafts'> when API returns different shape
  - Pre-existing type errors in agent-sdk tools are expected and not blockers (next.config.ts has ignoreBuildErrors: true)
  - projectKeys pattern: `all: ['projects']`, `detail: (id) => ['projects', id]` — follow this for other entity hooks
---

## 2026-01-22 - US-005
- What was implemented:
  - GET /api/projects — returns projects for authenticated user's studio, ordered by updatedAt desc, with _count.drafts
  - POST /api/projects — creates project with title, logline, genre, format; validates required fields (400 if missing)
  - GET /api/projects/[id] — returns project with drafts array ordered by draftNumber desc
  - All routes validate auth via getCurrentUser() — return 401 if unauthenticated
  - GET by ID also validates studio membership — returns 404 if project belongs to different studio
  - Returns 404 for non-existent project IDs
- Files changed:
  - src/app/api/projects/route.ts (new)
  - src/app/api/projects/[id]/route.ts (new)
- **Learnings for future iterations:**
  - API route pattern: use `getCurrentUser()` from `@/lib/auth` for auth, return 401 if null
  - Project access control: check `project.studioId !== user.studioId` to prevent cross-studio access
  - Next.js 15 dynamic route params are now a Promise — use `const { id } = await params` in route handlers
  - Include `_count: { select: { drafts: true } }` for list endpoints that need relation counts
  - POST routes should return 201 status on successful creation
---

## 2026-01-22 - US-006
- What was implemented:
  - Home view (`home-view.tsx`) refactored to use `useProjects()` React Query hook instead of Zustand store
  - Loading state shows 3 skeleton project cards with pulse animation
  - Empty state with 48px Target icon, "Create your first project" heading, and "New Project" button
  - Project cards display real data: title, logline, format badge, draft count from `_count.drafts`, last updated date
  - Error state for failed fetches
  - Project creation modal (`project-create-modal.tsx`) wired to `useCreateProject` mutation
  - Success toast on project creation, error toast on failure
  - Selecting a project calls `setCurrentProject` in Zustand and switches to Scout tab
  - Create button disabled while mutation is pending
- Files changed:
  - src/components/home/home-view.tsx (rewritten — uses useProjects hook, added skeleton loading)
  - src/components/home/project-create-modal.tsx (modified — uses useCreateProject mutation + toasts)
- **Learnings for future iterations:**
  - The `useProjects()` hook returns `ProjectWithCount[]` which has `_count: { drafts: number }` — use this instead of `project.drafts?.length`
  - Pre-existing type errors in agent-sdk tools don't block the build (ignoreBuildErrors: true in next.config.ts)
  - For optimistic updates with React Query, the modal's `onSuccess` callback is where you set Zustand state (setCurrentProject) and navigate
  - The home view no longer uses currentStudio from Zustand — the API already scopes projects by studio via the auth session
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-007
- What was implemented:
  - POST /api/projects/[id]/drafts — accepts multipart form data with PDF file and optional notes
  - Validates auth, project ownership (studio scoping), file type (PDF only), file size (10MB max)
  - Extracts text from PDF using pdfjs-dist (reuses same approach as /api/upload)
  - Stores PDF in Supabase Storage bucket 'scripts' at path '{projectId}/{draftNumber}.pdf'
  - Creates Draft record with auto-incremented draftNumber, scriptText, pageCount, notes, scriptUrl
  - Returns created Draft with id, draftNumber, pageCount, status, scriptUrl (201)
  - Supabase admin client created at src/lib/supabase/admin.ts for service-role storage operations
- Files changed:
  - src/app/api/projects/[id]/drafts/route.ts (new)
  - src/lib/supabase/admin.ts (new)
- **Learnings for future iterations:**
  - Supabase Storage upload needs service role key to bypass RLS — use createAdminClient() not the user-scoped client
  - getPublicUrl() is synchronous (no await needed) and returns `{ data: { publicUrl: string } }`
  - Draft draftNumber auto-increment: query `findFirst` with `orderBy: { draftNumber: 'desc' }` then add 1
  - The /api/upload route already has PDF extraction logic — for the drafts route we duplicated it locally to also return pageCount
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-008
- What was implemented:
  - useUploadDraft mutation hook at src/hooks/use-drafts.ts — POST FormData to /api/projects/[id]/drafts
  - DraftUploadModal refactored to use useUploadDraft mutation instead of local Zustand state
  - Upload progress indicator: Loader2 spinning icon + "Extracting text..." message during API call
  - Success toast: "Draft uploaded — {pageCount} pages extracted"
  - Error toast: shows the API error message for corrupt/password-protected PDFs
  - After success: invalidates project query (projects list + detail) so draft count updates
  - Modal closes on success, stays open on error
  - All interactive elements disabled during upload (backdrop click, close button, cancel, notes textarea)
  - setCurrentDraft called on success with proper DraftStatus type cast
- Files changed:
  - src/hooks/use-drafts.ts (new — useUploadDraft mutation hook)
  - src/components/home/draft-upload-modal.tsx (rewritten — wired to API with progress/toasts)
- **Learnings for future iterations:**
  - DraftStatus type is 'PENDING' | 'ANALYZING' | 'COMPLETED' | 'FAILED' — not 'COMPLETE' or 'ERROR'
  - useMutation.isPending is the React Query v5 way to check loading state (replaces isLoading)
  - uploadMutation.reset() should be called in resetAndClose to clear error state on re-open
  - The draft upload API returns pageCount as `number | null` — use nullish coalescing for display
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-009
- What was implemented:
  - Refactored scout-chat.tsx to use Zustand store's `chatMessages` and `isStreaming` instead of local useState
  - Messages now persist across tab switches within the session (stored in Zustand, not localStorage)
  - Added `updateChatMessage(id, updates)` method to store for targeted message updates during streaming
  - Added `StoreChatMessage` exported type to app-store matching ChatMessage fields (with optional timestamp)
  - SSE streaming works via `createSSEConnection` from event-router.ts (already existed)
  - text_delta events append content token-by-token to assistant message via `updateChatMessage`
  - text_complete events finalize message by setting `isStreaming: false`
  - Error handling: connection failures show system error message in chat with "Click Retry" text
  - Retry button appears below chat when error messages exist — cleans up error messages and resends last request
  - system type=error SSE events display as red error messages (system role messages in ChatInterface)
  - Input disabled during streaming via Zustand `isStreaming` state
- Files changed:
  - src/stores/app-store.ts (modified — added StoreChatMessage type, updateChatMessage method, optional timestamp)
  - src/components/scout/scout-chat.tsx (rewritten — uses Zustand chatMessages, added retry mechanism)
- **Learnings for future iterations:**
  - ChatMessage from chat-interface.tsx has `timestamp?: Date` (optional) — StoreChatMessage must match
  - `useAppStore.getState()` is used in handleRetry for direct state access outside React rendering
  - `useAppStore.setState({ chatMessages: filtered })` can be used for bulk state updates not covered by actions
  - chatMessages are NOT in the persist partialize — they persist in memory across tab switches but not page refreshes
  - Error markers use `__error__:` prefix in system messages for internal tracking, stripped for display
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-010
- What was implemented:
  - Inline tool status pills rendered on the assistant message during Scout tool calls
  - tool_start events add a ToolCallStatus entry (running) with gold spinner pill
  - tool_end events update the matching pill to complete state (green checkmark)
  - ToolCallStatus type added to both app-store (StoreChatMessage.toolCalls) and chat-interface (ChatMessage.toolCalls)
  - Pills rendered via Framer Motion scale-in animation within the MessageBubble component
  - TOOL_DISPLAY_NAMES mapping updated per AC: spawn_readers → 'Analyzing with readers...', focus_group → 'Running focus group...', executive_eval → 'Evaluating with executives...', reader_chat → 'Chatting with reader...'
  - File attachment feature (Paperclip button, file picker, drag-and-drop, PDF upload via /api/upload, filename chip) was already present in ChatInterface from working tree — committed as part of US-010
  - onResult handler marks any remaining running tools as complete
  - currentAssistantIdRef and toolCallsRef track the active message's tool state across callbacks
- Files changed:
  - src/stores/app-store.ts (modified — added ToolCallStatus interface, toolCalls field on StoreChatMessage)
  - src/components/chat/chat-interface.tsx (modified — added ToolCallStatus interface, toolCalls on ChatMessage, tool pill rendering in MessageBubble, full file attachment UI)
  - src/components/scout/scout-chat.tsx (modified — added tool call tracking refs, updated onToolStart/onToolEnd/onResult handlers)
- **Learnings for future iterations:**
  - Tool pills are tracked as an array on the assistant message (toolCalls) rather than separate system messages — this keeps them visually grouped with the response
  - Use refs (currentAssistantIdRef, toolCallsRef) for callback-scoped state that needs to persist across SSE events without causing re-renders
  - MCP tool names come as 'mcp__bullseye-tools__ingest_script' — strip prefix with split('__').pop() to get base name for display mapping
  - The ToolCallStatus type is defined in both app-store and chat-interface — they're structurally identical so TypeScript treats them as compatible
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-011
- What was implemented:
  - SSE event routing automatically switches right panel mode based on event source
  - reader_maya/reader_colton/reader_devon source with analysis_start type → switches to 'analysis' mode
  - focus_group source events → switches to 'focus_group' mode
  - reader_chat source events → switches to 'reader_chat' mode
  - executive source events → switches to 'executive' mode
  - ScoutEventSource type extended with 'reader_chat' and 'executive' sources
  - Phase change guard in scout-chat prevents redundant updates (checks current mode before switching)
  - Prevents focus group messages from being cleared if already in focus_group mode
  - Framer Motion transitions updated from 300ms to 200ms per AC
  - Idle state shows 'Reader activity will appear here' (exact AC text)
  - ScoutLayout renders 5 panel modes: idle, analysis, focus_group, reader_chat, executive
  - All non-idle panels use fade+slide animation (opacity 0→1, x: 20→0 enter, x: 0→-20 exit)
- Files changed:
  - src/lib/agent-sdk/types.ts (modified — added reader_chat and executive to ScoutEventSource)
  - src/lib/agent-sdk/event-router.ts (modified — auto-switch panel mode on source-based events, added reader_chat/executive cases)
  - src/components/scout/scout-layout.tsx (modified — updated idle text, changed transition duration to 0.2s)
  - src/components/scout/scout-chat.tsx (modified — added phase change guard to prevent redundant updates)
- **Learnings for future iterations:**
  - Radix ScrollArea doesn't forward refs — use native `div` with `overflow-y-auto` when you need scrollTop access
- For follow-up inputs in sub-panels, wire full EventRouterCallbacks to createSSEConnection — use `useAppStore.getState()` in callbacks
- Event router's `routeEvent` function switches on `event.source` — new source types need case statements here
  - Phase change guard pattern: `const currentMode = useAppStore.getState().rightPanelMode; if (currentMode !== phase) { ... }` prevents redundant state updates and side effects like clearing messages
  - ScoutLayout uses AnimatePresence with `mode="wait"` for sequential panel transitions (exit → enter, not overlap)
  - focus_group source events fire for every message — calling onPhaseChange every time is fine since the guard in scout-chat prevents redundant updates
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-012
- What was implemented:
  - Reader analysis right panel with live streaming results, expandable/collapsible cards, and harmonized scores
  - 3 reader cards (Maya, Colton, Devon) with colored left borders when complete
  - reader_start events set card to 'Analyzing...' with pulse animation (or progress bar if progress events arrive)
  - reader_progress events (via analysis_stream SSE type) update a progress bar on the reader card
  - reader_complete events populate: recommendation badge, overall score bar, strengths, concerns, standout quote
  - ScoreBars component: 10-bar visualization with staggered left-to-right fill animation (300ms duration, 50ms stagger per bar)
  - Harmonized Scores section appears at top after all 3 readers complete — averages all reader scores
  - Cards are expandable/collapsible using Zustand expandedReaders state with ChevronDown rotation
  - Collapsed card shows overall score + recommendation; expanded shows all dimension scores + strengths/concerns/quote
  - Added progress field to ReaderStreamState type
  - Added onReaderProgress callback to EventRouterCallbacks
  - Added analysis_stream routing in event-router for progress updates
- Files changed:
  - src/components/scout/reader-analysis-panel.tsx (rewritten — expandable cards, score bars, harmonized scores, progress indicator)
  - src/lib/agent-sdk/types.ts (modified — added progress field to ReaderStreamState)
  - src/lib/agent-sdk/event-router.ts (modified — added onReaderProgress callback, analysis_stream routing)
  - src/components/scout/scout-chat.tsx (modified — added onReaderProgress handler, progress init on reader start)
- **Learnings for future iterations:**
  - expandedReaders and toggleReaderExpanded are already in Zustand UI state — use these for any expand/collapse patterns
  - ScoreBars uses Framer Motion scaleX with transformOrigin: 'left' for left-to-right fill animation
  - numericToFilled(value) converts 0-100 scores to 0-10 filled bars (Math.round(value / 10))
  - computeHarmonizedScores iterates all 3 readers and averages per dimension — graceful with missing data
  - analysis_stream is the SSE event type for reader progress updates (not a separate reader_progress type)
  - AnimatePresence with height: 0/auto for expand/collapse transitions needs overflow-hidden on the motion.div
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-013
- What was implemented:
  - Focus group panel with chat-style message list, reader avatars, and colors
  - focus_group_message SSE events append messages with reader name, color, and avatar (was already wired via event-router)
  - Moderator (Scout) messages styled with gold accent border (border-l-2, #D4A84B color)
  - Typing indicator shows reader name + animated dots before message arrives
  - Messages auto-scroll to bottom via native div with overflow-y-auto + useEffect scrollTop
  - Follow-up question input at bottom — sends user message to Scout via /api/scout SSE
  - Follow-up input wires full EventRouterCallbacks so focus group messages still route to Zustand
  - Messages stored in Zustand focusGroupMessages array (persists across tab switches)
- Files changed:
  - src/components/scout/focus-group-panel.tsx (rewritten — added gold border, follow-up input, scroll fix, proper ES imports)
- **Learnings for future iterations:**
  - Radix ScrollArea doesn't forward refs to the viewport — use native `div` with `overflow-y-auto` when you need `scrollRef.current.scrollTop` access
  - For follow-up inputs in sub-panels (focus group, reader chat), wire a full EventRouterCallbacks object to createSSEConnection — use `useAppStore.getState()` in callbacks for fresh state
  - Gold accent color for moderator/Scout is `#D4A84B` — use `border-l-2` with inline `borderLeftColor` style (Tailwind can't do arbitrary colors inline)
  - The focus-group-panel.tsx file was previously untracked — it's a new file in this branch
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-014
- What was implemented:
  - Reader chat right panel with per-reader conversation history in Zustand
  - ReaderChatMessage type and readerChatMessages (Record<string, ReaderChatMessage[]>) added to Zustand store
  - addReaderChatMessage(readerId, message) and updateReaderChatMessage(readerId, messageId, updates) actions added
  - Conversations persist per reader — switching readers or navigating away doesn't lose history
  - Back button (ChevronLeft) returns to reader selector without clearing messages
  - Header shows "Chatting with {reader.name}" per AC
  - Native div with overflow-y-auto replaces Radix ScrollArea for proper scrollTop ref access
  - Reader selector shows 3 avatars with colored circles and initials
  - SSE streaming via POST /api/reader-chat with readerId, message, projectId, draftId, conversationHistory
  - text_delta events stream token-by-token into assistant message via updateReaderChatMessage
  - text_complete events finalize the message
  - Typing indicator with animated dots while waiting for first token
  - Error handling updates assistant message with error text
- Files changed:
  - src/stores/app-store.ts (modified — added ReaderChatMessage type, readerChatMessages state, add/update actions)
  - src/components/scout/reader-chat-panel.tsx (rewritten — uses Zustand for per-reader message persistence)
- **Learnings for future iterations:**
  - Per-reader chat messages are stored as Record<string, ReaderChatMessage[]> keyed by readerId — not a flat array
  - Back button only clears activeReaderChatId (not messages) — this preserves history when returning to selector
  - ReaderChatMessage is exported from app-store for use in the panel component's ChatBubble props
  - The reader-chat-panel.tsx was previously untracked — it's a new file in this branch
  - conversationHistory sent to /api/reader-chat is built from Zustand messages (excluding the streaming placeholder)
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-015
- What was implemented:
  - Executive evaluation right panel component at src/components/scout/executive-eval-panel.tsx
  - ExecutiveStreamState type added to src/lib/agent-sdk/types.ts (status, verdict, confidence, rationale, keyFactors, concerns)
  - executive_start and executive_complete SSE event types added to ScoutEventType union
  - executiveId and executiveName fields added to ScoutSSEEvent for executive routing
  - onExecutiveStart and onExecutiveComplete callbacks added to EventRouterCallbacks
  - Event router executive case updated to parse executive_start/executive_complete events
  - executiveStates Map added to Zustand store (ScoutSessionState) with setExecutiveState/clearExecutiveStates actions
  - scout-chat.tsx wired with executive callbacks (setExecutiveState on start/complete)
  - focus-group-panel.tsx updated with no-op executive callbacks for type conformance
  - ScoutLayout updated to render ExecutiveEvalPanel instead of placeholder text
  - Panel shows: executives list with loading spinners (evaluating), verdict badge (PURSUE green / PASS red), confidence %, rationale, key factors, concerns
  - Results accumulate as each executive completes, persisted in Zustand Map
- Files changed:
  - src/lib/agent-sdk/types.ts (modified — added ExecutiveStreamState, executive_start/complete event types, executiveId/executiveName on SSE event)
  - src/lib/agent-sdk/event-router.ts (modified — added executive callbacks, updated executive case routing)
  - src/stores/app-store.ts (modified — added executiveStates Map, setExecutiveState, clearExecutiveStates)
  - src/components/scout/scout-chat.tsx (modified — added setExecutiveState destructure, executive callbacks, dependency array)
  - src/components/scout/focus-group-panel.tsx (modified — added onExecutiveStart/onExecutiveComplete no-ops)
  - src/components/scout/scout-layout.tsx (modified — import ExecutiveEvalPanel, replace placeholder)
  - src/components/scout/executive-eval-panel.tsx (new — full executive eval panel component)
- **Learnings for future iterations:**
  - When adding new callbacks to EventRouterCallbacks, also update focus-group-panel.tsx which has its own inline callbacks object for follow-up messages
  - ExecutiveStreamState uses Map<string, ExecutiveStreamState> (like readerStates) — not a flat array, so entries accumulate and persist across panel switches
  - Pre-existing type errors in agent-sdk/tools/ and api/reader-chat/ are NOT caused by new changes — they're pre-existing Prisma JSON type issues
  - The event router 'executive' case previously only called onPhaseChange — now it also handles executive_start/executive_complete sub-events
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-016
- What was implemented:
  - GET /api/drafts/[id]/deliverable — returns DraftDeliverable with all JSON fields (harmonizedCoverage, harmonizedScores, readerPerspectives, scoutAnalysis, studioCalibration)
  - Returns 404 if no deliverable exists for the draft
  - GET /api/drafts/[id]/focus-sessions — returns FocusSessions with messages, ordered by createdAt desc
  - Each focus session includes messages ordered by sequenceNumber asc
  - Both routes validate auth via getCurrentUser() — return 401 if unauthenticated
  - Both routes verify draft belongs to user's studio via project.studioId check — return 404 for access violations
  - Both routes return 404 for non-existent draft IDs
- Files changed:
  - src/app/api/drafts/[id]/deliverable/route.ts (new)
  - src/app/api/drafts/[id]/focus-sessions/route.ts (new)
- **Learnings for future iterations:**
  - Draft access control pattern: findUnique draft with `include: { project: { select: { studioId: true } } }`, then check `draft.project.studioId !== user.studioId`
  - DraftDeliverable has a unique constraint on draftId — use `findUnique({ where: { draftId: id } })` not `findFirst`
  - FocusSession messages should be ordered by sequenceNumber (not createdAt) for correct conversation ordering
  - Pre-existing type errors in agent-sdk/tools/ are known and don't block new API routes (ignoreBuildErrors: true)
---

## 2026-01-22 - US-017
- What was implemented:
  - GET /api/drafts/[id]/evaluations — returns ExecutiveEvaluations with executive profile data included, ordered by createdAt desc
  - GET /api/studio — returns current user's Studio with _count of readerPersonas and projects
  - PUT /api/studio — accepts { name } and updates the studio record (validates name is non-empty string)
  - GET /api/studio/readers — returns ReaderPersonas for the user's studio, ordered by createdAt asc
  - PUT /api/studio/readers/[id] — accepts persona fields and updates the record (validates ownership)
  - GET /api/studio/executives — returns ExecutiveProfiles for the user's studio, ordered by createdAt asc
  - PUT /api/studio/executives/[id] — accepts profile fields and updates the record (validates ownership)
  - GET /api/studio/intelligence — returns StudioIntelligence for the user's studio (404 if not found)
  - All routes validate auth via getCurrentUser() — return 401 if unauthenticated
  - PUT routes verify entity belongs to user's studio before allowing updates
- Files changed:
  - src/app/api/drafts/[id]/evaluations/route.ts (new)
  - src/app/api/studio/route.ts (new)
  - src/app/api/studio/readers/route.ts (new)
  - src/app/api/studio/readers/[id]/route.ts (new)
  - src/app/api/studio/executives/route.ts (new)
  - src/app/api/studio/executives/[id]/route.ts (new)
  - src/app/api/studio/intelligence/route.ts (new)
- **Learnings for future iterations:**
  - Studio entity access control: reader/executive entities have `studioId` field — check `entity.studioId !== user.studioId` directly (no need for project relation join)
  - PUT routes use conditional spread for optional fields: `...(body.field !== undefined && { field: body.field })` — allows partial updates without overwriting unset fields
  - Studio GET uses `_count: { select: { readerPersonas: true, projects: true } }` for relation counts
  - ExecutiveEvaluation includes `executive: true` in the findMany to get profile data inline
  - StudioIntelligence has unique constraint on studioId — use `findUnique({ where: { studioId } })`
---

## 2026-01-22 - US-018
- What was implemented:
  - useDrafts(projectId) hook fetches drafts from project detail endpoint, staleTime 30s
  - draftKeys query key factory exported from use-drafts.ts for cache invalidation (list, deliverable, focusSessions, evaluations)
  - useDeliverable(draftId) hook fetches GET /api/drafts/[id]/deliverable, staleTime 5min, returns null for 404
  - useFocusSessions(draftId) hook fetches GET /api/drafts/[id]/focus-sessions, staleTime 30s
  - useEvaluations(draftId) hook fetches GET /api/drafts/[id]/evaluations, staleTime 30s
  - useStudio() hook fetches GET /api/studio, staleTime 10min
  - useReaderPersonas() hook fetches GET /api/studio/readers, staleTime 30s
  - useExecutiveProfiles() hook fetches GET /api/studio/executives, staleTime 30s
  - useStudioIntelligence() hook fetches GET /api/studio/intelligence, staleTime 10min, returns null for 404
  - All hooks return { data, isLoading, error } and handle undefined/null gracefully via `enabled` guard
  - Response types defined for all API shapes (DeliverableResponse, FocusSessionResponse, EvaluationResponse, StudioResponse, ReaderPersonaResponse, ExecutiveProfileData, StudioIntelligenceResponse)
- Files changed:
  - src/hooks/use-drafts.ts (modified — added useDrafts hook and draftKeys factory)
  - src/hooks/use-studio.ts (new — useDeliverable, useFocusSessions, useEvaluations, useStudio, useReaderPersonas, useExecutiveProfiles, useStudioIntelligence)
- **Learnings for future iterations:**
  - draftKeys pattern: `list: (projectId) => ['drafts', projectId]`, `deliverable: (draftId) => ['drafts', draftId, 'deliverable']` etc. — use these for cache invalidation in mutations
  - useDeliverable and useStudioIntelligence return null (not throw) for 404 responses — components should check `data === null` for empty state
  - useDrafts fetches from the project detail endpoint (GET /api/projects/[id]) and extracts `.drafts` array — reuses existing route rather than a separate drafts list endpoint
  - studioKeys exported from use-studio.ts for external cache invalidation (e.g., after PUT updates in studio configuration views)
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-019
- What was implemented:
  - Coverage view wired to useDeliverable(currentDraft.id) React Query hook for real API data
  - Prefers Zustand currentDeliverable (live/streaming data from SSE) over fetched API data — seamless handoff between live analysis and persisted results
  - API response JSON fields (typed as `unknown` in DeliverableResponse) cast to proper typed interfaces (CoverageReport, HarmonizedScores, ReaderPerspective[], ScoutAnalysis, StudioCalibration, IntakeReport)
  - Loading skeleton with 3 score bar skeletons (10-bar visualization placeholder) + 3 reader card skeletons (avatar, name, 6 mini-scores, evidence bar)
  - Empty state uses BarChart3 icon (per AC), 'No Coverage Yet' heading, 'Run analysis from Scout to see coverage' text, and 'Go to Scout →' button that calls setActiveTab('scout')
  - Removed unused imports (FileText, Target, motion from EmptyState already used)
  - CoverageContent and IntakeContent typed with proper interfaces instead of DraftDeliverable['field'] accessor types
- Files changed:
  - src/components/coverage/coverage-view.tsx (rewritten — uses useDeliverable hook, added LoadingSkeleton, updated EmptyState with Scout link)
- **Learnings for future iterations:**
  - Coverage view priority: Zustand `currentDeliverable` > React Query `useDeliverable` data > null (empty state). This ensures live streaming results show immediately while persisted data loads from API for return visits
  - DeliverableResponse from use-studio.ts types JSON fields as `unknown` — must cast in consumer components (this is intentional since Prisma JSON fields have no schema validation)
  - EmptyState components should accept onAction callback (not import setActiveTab directly) for reusability and testability
  - Loading skeletons should match real component dimensions closely — use same rounded corners, gaps, and grid layouts as the populated state
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-020
- What was implemented:
  - Focus view refactored to use `useFocusSessions(currentDraft.id)` React Query hook for real session data
  - Session list shows each session with topic (or "Focus Group Session" fallback), formatted date, message count, and status badge (Completed green, Active amber)
  - Selecting a session renders full message transcript with reader avatars and persona colors
  - Moderator (Scout) messages styled with gold accent border (2px solid #D4A84B) and gold name color
  - Reader messages styled with 3px left border in their persona color (from DEFAULT_READERS lookup)
  - User messages styled right-aligned with primary color background
  - Back button in transcript header returns to session list without losing context
  - Loading skeleton shows 3 session card skeletons with title, badge, date, and message count placeholders
  - Empty state uses Users icon (48px), "No Focus Groups Yet" heading, explanation text, and "Go to Scout" button that calls setActiveTab('scout')
  - Removed all simulated/demo focus group logic — view is now purely data-driven from API
- Files changed:
  - src/components/focus/focus-view.tsx (rewritten — uses useFocusSessions hook, session list + transcript views, loading/empty states)
- **Learnings for future iterations:**
  - FocusSessionMessage speakerType from DB is uppercase ('MODERATOR', 'READER', 'USER') — different from the FocusGroupMessage type which uses lowercase ('moderator', 'reader', 'user')
  - Reader info for transcript messages should use DEFAULT_READERS lookup by readerId — not the readerPerspectives from Zustand (which may not be populated if user navigates directly to Focus tab)
  - Session list uses motion.button (not motion.div with onClick) for proper keyboard accessibility
  - Native div with overflow-y-auto for scroll containers (pattern from US-013/US-014)
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-021
- What was implemented:
  - Revisions view refactored to use `useDrafts(currentProject.id)` React Query hook for real draft data
  - Left sidebar timeline shows drafts sorted by draftNumber desc with: draft number, date, page count, "Analyzed" badge for COMPLETED status
  - Selecting a draft fetches its deliverable via `useDeliverable(draftId)` and shows harmonized scores in main panel
  - Compare mode: selecting a second draft fetches its deliverable and shows score deltas with directional arrows (green ArrowUp, red ArrowDown, gray Minus)
  - DeltaSummary component shows grid of score changes with colored indicators
  - Reader perspectives from deliverable rendered as ReaderMemoryCards with strengths, concerns, and standout quote
  - DEFAULT_READERS lookup matches reader names to colors/voiceTags for consistent presentation
  - "Upload New Draft" button in timeline sidebar opens DraftUploadModal
  - Loading skeleton shows timeline skeleton (3 items) + score table skeleton (6 bars) + reader card skeletons (3 cards)
  - Empty state shows GitBranch icon (48px), "No Drafts Yet" heading, description, and "Upload First Draft" button that opens DraftUploadModal
  - Removed all mock data and simulated drafts — view is now purely data-driven from API
  - Score bars animate with Framer Motion (width 0 → value%, 400ms ease-out)
  - Removed unused types (DraftData, DeliverableData) after initial implementation
- Files changed:
  - src/components/revisions/revisions-view.tsx (rewritten — uses useDrafts + useDeliverable hooks, added compare mode, loading/empty states)
- **Learnings for future iterations:**
  - useDrafts returns UploadDraftResponse[] from the project detail endpoint — createdAt is a string (ISO), needs `new Date()` for display
  - useDeliverable returns DeliverableResponse with JSON fields typed as `unknown` — must cast to HarmonizedScores/ReaderPerspective[] in consumer
  - Compare mode needs two separate useDeliverable calls — one for selected draft, one for comparison draft (both enabled conditionally)
  - DraftUploadModal requires currentProject in Zustand to be set — the revisions view already has currentProject from useAppStore
  - The drafts array from useDrafts comes sorted by draftNumber desc (from project detail endpoint) — no need to re-sort for "latest first" display
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-022
- What was implemented:
  - Pitch view rewritten to use real data from `useExecutiveProfiles()` and `useEvaluations(currentDraft.id)` React Query hooks
  - Executive cards show real DB profiles (name, title, company) with avatar initials
  - `useDeliverable(currentDraft.id)` used to check if coverage analysis has been run (prerequisite for exec eval)
  - Prefers Zustand `currentDeliverable` (live) over API data for hasDeliverable check
  - "Run Simulation" button sends message to `/api/scout` via `createSSEConnection` with executive SSE callbacks
  - Per-executive loading spinner overlay during evaluation (from Zustand executiveStates Map)
  - Live streaming results rendered as `LiveResults` component — shows completed executive eval cards as they stream in
  - Persisted results rendered as `PersistedResults` component — shows saved evaluations from API on return visits
  - Results include: PURSUE/PASS badge, confidence %, rationale, key factors as bullets, concerns as bullets, cited coverage elements
  - Summary card shows Pursue/Pass counts and success rate Progress bar
  - Loading skeleton: header + 3 executive card skeletons + 2 result card skeletons (all with pulse animation)
  - Two empty states: no draft selected → "Select a Project" + Home link, no deliverable → "No Evaluations Yet" + "Complete coverage analysis first" + Scout link
  - Removed all mock/simulated evaluation logic (delay, random verdict generation)
  - Removed dependency on `DEFAULT_EXECUTIVES` from `@/lib/executive` — now uses API data
  - Removed unused Zustand actions (startEvaluation, addEvaluation, endEvaluation, etc.) from component destructure
- Files changed:
  - src/components/pitch/pitch-view.tsx (rewritten — uses useExecutiveProfiles + useEvaluations hooks, SSE for Run Simulation, loading/empty states)
- **Learnings for future iterations:**
  - EvaluationResponse from API has uppercase verdict ('PURSUE'/'PASS') while live SSE may send lowercase — handle both with `=== 'pursue' || === 'PURSUE'`
  - Live executive results (from Zustand executiveStates Map) take priority over persisted results (from API) when hasLiveResults is true — prevents showing stale data during active evaluation
  - createSSEConnection can be called from any component (not just scout-chat) — provide full EventRouterCallbacks with no-op handlers for unneeded events
  - Pitch view has two entry points for evaluation data: live streaming (Zustand executiveStates) and persisted (useEvaluations API hook)
  - The `connectionRef` is important to prevent garbage collection of the SSE connection
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-023
- What was implemented:
  - Studio configuration view rewritten to use real API data via React Query hooks
  - Readers tab: uses `useReaderPersonas()` hook, displays editable fields (name, displayName, background, voiceDescription, weights)
  - Readers save: PUT /api/studio/readers/[id] via useMutation, invalidates studioKeys.readers, shows success toast
  - Executives tab: uses `useExecutiveProfiles()` hook, displays editable fields (name, title, company, priorityFactors, dealBreakers)
  - Executives save: PUT /api/studio/executives/[id] via useMutation, invalidates studioKeys.executives, shows success toast
  - Calibration tab: uses `useStudioIntelligence()` hook, shows totalProjectsAnalyzed, recommendationBreakdown (recommend/consider/pass), scoreDistributions percentiles
  - Calibration empty state: when intelligence is null, shows BarChart3 icon with "No calibration data yet" message
  - Settings tab: uses `useStudio()` hook, editable studio name field, save calls PUT /api/studio
  - Inline validation: required fields show red border (border-danger class) and red error text when empty on save attempt
  - Loading skeletons for all tabs via SectionSkeleton component (pulse animated cards matching real component dimensions)
  - All save buttons show Loader2 spinner during mutation, disabled while pending
  - Edit mode: toggle with Edit2/X buttons, Cancel resets fields to original values
  - Removed all imports of DEFAULT_READERS and DEFAULT_EXECUTIVES (no more static data)
- Files changed:
  - src/components/studio/studio-view.tsx (rewritten — uses useReaderPersonas, useExecutiveProfiles, useStudioIntelligence, useStudio hooks + useMutation for saves)
- **Learnings for future iterations:**
  - StudioIntelligence JSON fields (scoreDistributions, recommendationBreakdown) typed as `unknown` from React Query — must cast to typed interfaces in component
  - Reader persona weights are stored as individual columns (premiseWeight, characterWeight, etc.) not as a JSON weights object — map individually in edit forms
  - Executive priorityFactors and dealBreakers are string arrays in the DB — for edit UI, use comma-separated text input and split on save
  - Settings section initializes state from API data using a one-time flag pattern (`initialized` state) to avoid overwriting user edits on re-render
  - useMutation's onSuccess callback is the right place to invalidate queries + close edit mode — ensures fresh data replaces stale form values
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-024
- What was implemented:
  - Skeleton base component at src/components/shared/skeleton.tsx with bg-elevated and animate-pulse
  - ProjectCardSkeleton: matches project card (rounded-2xl, p-5, status dot, title bar, logline lines, footer badges)
  - ReaderCardSkeleton: matches reader card (avatar w-9 h-9 rounded-xl, name, 6 mini scores grid-cols-2, evidence bar, expand trigger)
  - ScoreBarSkeleton: matches 10-bar ScoreIndicator (label w-[72px], 10 bars with gap-[2px] and rounded-[2px], rating label)
  - ChatMessageSkeleton: matches chat bubble (avatar w-7 h-7 rounded-lg, agent name, 2-3 text lines varying widths)
  - TimelineItemSkeleton: matches revisions timeline (dot w-3 h-3 rounded-full at left-2.5 top-4, draft number + badge, date, page count)
  - All skeletons use rounded corners matching real component radii
- Files changed:
  - src/components/shared/skeleton.tsx (new)
- **Learnings for future iterations:**
  - Existing inline skeletons in home-view, coverage-view, revisions-view etc. already follow these exact patterns — the shared components are consistent with them
  - Pre-existing ui/skeleton.tsx uses bg-accent — the shared/skeleton.tsx uses bg-elevated to match the app's actual skeleton usage pattern
  - ChatMessageSkeleton accepts `lines` prop (2-3) for varying message lengths
  - All skeleton components are named exports, no default export — import as `{ ProjectCardSkeleton }` etc.
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-025
- What was implemented:
  - ErrorBoundary class component at src/components/shared/error-boundary.tsx
  - Uses getDerivedStateFromError for React error catching
  - Fallback UI: AlertCircle icon (48px/w-12), error message, 'Try Again' button that resets state
  - Accepts optional `fallback` prop for custom fallback UI
  - Each tab view in page.tsx wrapped with `<ErrorBoundary key={tab}>` — key ensures boundary resets on tab switch
  - Coverage view: added `error` destructuring from useDeliverable, inline error state with AlertTriangle icon
  - Focus view: added `error` from useFocusSessions, inline error state
  - Revisions view: added `error` from useDrafts, inline error state
  - Pitch view: added `error` from useExecutiveProfiles + useEvaluations, inline error state
  - Studio view: added `error` to all 4 sub-sections (ReadersSection, ExecutivesSection, CalibrationSection, SettingsSection)
  - SSE stream errors already handled by scout-chat (US-009) with retry button — no changes needed
- Files changed:
  - src/components/shared/error-boundary.tsx (new)
  - src/app/page.tsx (modified — imported ErrorBoundary, wrapped each view)
  - src/components/coverage/coverage-view.tsx (modified — added error destructuring + inline error state)
  - src/components/focus/focus-view.tsx (modified — added error handling + AlertTriangle import)
  - src/components/revisions/revisions-view.tsx (modified — added error handling + AlertTriangle import)
  - src/components/pitch/pitch-view.tsx (modified — added error handling + AlertTriangle import)
  - src/components/studio/studio-view.tsx (modified — added error handling to 4 sub-sections + AlertTriangle import)
- **Learnings for future iterations:**
  - ErrorBoundary uses `key` prop to reset when tab changes — without this, switching tabs after an error would still show the error fallback
  - React Query hooks return `{ error }` typed as `Error | null` — destructure and display `error.message` for user-facing text
  - Inline error states (AlertTriangle + red text) are better UX than throwing to the ErrorBoundary for data fetch failures — the boundary catches unexpected render errors
  - Pre-existing type errors in agent-sdk/tools/ are known (Prisma JSON type issues) and don't affect the build (ignoreBuildErrors: true)
  - The pattern for inline error states: `if (error) { return <div><AlertTriangle /><p>{error.message}</p></div>; }` — goes after loading check, before data rendering
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-026
- What was implemented:
  - Shared EmptyState component at src/components/shared/empty-state.tsx
  - Accepts props: icon (LucideIcon), title (string), description (string), actionLabel? (string), onAction? (callback)
  - Uses Framer Motion fade-in animation (opacity 0→1, y 8→0, 500ms duration)
  - Styled with bg-surface icon container (48px, rounded-2xl), bullseye-gold action text link
  - ScoutView updated with two empty states:
    - No project: FileText icon, "Select a project first", "Choose a project from Home to start analyzing", "Go to Home" link
    - No draft: Upload icon, "Upload a script to get started", "Upload a screenplay PDF..." description, "Upload Script" button opening DraftUploadModal
  - All other views verified to already have proper empty states matching AC:
    - Home: Target icon, "Create your first project", New Project button
    - Coverage: BarChart3 icon, "No Coverage Yet", "Run analysis from Scout", Scout link
    - Focus: Users icon, "No Focus Groups Yet", "Start a focus group from Scout", Scout link
    - Revisions: GitBranch icon, "No Drafts Yet", "Upload First Draft" button
    - Pitch: Briefcase icon, two states (no project → Home link, no deliverable → "Complete coverage analysis first")
- Files changed:
  - src/components/shared/empty-state.tsx (new — shared reusable component)
  - src/components/scout/scout-view.tsx (modified — replaced simulated chat with empty state checks before ScoutLayout)
- **Learnings for future iterations:**
  - The shared EmptyState component uses `type LucideIcon` from lucide-react — import as `import { type LucideIcon } from 'lucide-react'`
  - ScoutView previously had a full simulated chat (mock responses, progress banner) — this was all dead code replaced by ScoutChat in scout-layout.tsx
  - The old scout-view.tsx imported uuid, Card, Progress, Badge, Button — all unused after rewrite since real chat is in scout-chat.tsx
  - EmptyState actionLabel/onAction are optional — render nothing if not provided (for display-only states)
  - Browser verification not available — manual testing needed
---

## 2026-01-22 - US-027
- What was implemented:
  - Left icon rail hidden on mobile (< 768px) with `hidden md:flex`
  - Mobile bottom tab bar: fixed to bottom, same icons as sidebar (Home + 6 project tabs), gold active indicator via layoutId animation
  - Bottom tab bar shows icon + small label text (9px) for each tab, with disabled state for no-project
  - Safe-area-bottom CSS utility added for iOS notch/home indicator spacing
  - Main content area padded for bottom bar (pb-16 md:pb-0)
  - Project grid already used `grid-cols-1 md:grid-cols-2 lg:grid-cols-3` (single column on mobile)
  - Modals (DraftUploadModal, ProjectCreateModal) render as bottom sheets on mobile: items-end + rounded-t-2xl + max-h-[90vh]
  - Chat input naturally stays at bottom of viewport within flex layout
  - Reader cards grid changed from `md:grid-cols-3` to `lg:grid-cols-3` (< 1024px = single column)
  - ScoreIndicator: responsive label widths (w-16 sm:w-24), hidden rating text on mobile, flex-shrink-0 on bars
  - Coverage view: strengths/weaknesses, intake fields, and what-works/needs-work grids now `grid-cols-1 sm:grid-cols-2`
  - Pitch view: key-factors/concerns grids now `grid-cols-1 sm:grid-cols-2`
  - Studio view: executive name/title/company grid now `grid-cols-1 sm:grid-cols-3`, weights grid `grid-cols-3 sm:grid-cols-5`, calibration stats `grid-cols-2 sm:grid-cols-4`
  - Context bar: responsive text sizes (text-lg md:text-2xl), truncating project title, tighter gaps on mobile
  - Content area padding: `px-4 md:px-8` throughout
  - All text readable without horizontal scrolling at 375px viewport width
- Files changed:
  - src/components/layout/app-shell.tsx (modified — hidden md:flex on nav, pb-16 md:pb-0, mobile bottom tab bar, responsive context bar)
  - src/app/globals.css (modified — added safe-area-bottom utility)
  - src/components/home/draft-upload-modal.tsx (modified — bottom sheet on mobile)
  - src/components/home/project-create-modal.tsx (modified — bottom sheet on mobile)
  - src/components/shared/reader-card.tsx (modified — lg:grid-cols-3 on ReaderComparison)
  - src/components/shared/score-indicator.tsx (modified — responsive label widths, hidden rating text on mobile)
  - src/components/coverage/coverage-view.tsx (modified — responsive grid-cols on 3 grids)
  - src/components/pitch/pitch-view.tsx (modified — responsive grid-cols on 2 grids + reader cards)
  - src/components/studio/studio-view.tsx (modified — responsive grid-cols on 3 grids)
- **Learnings for future iterations:**
  - Mobile bottom bar needs `z-40` (not z-50) so modals render on top of it
  - Tailwind v4 doesn't require explicit breakpoint config — default sm(640), md(768), lg(1024) breakpoints work
  - `pb-16 md:pb-0` on main content compensates for the 64px bottom bar height on mobile
  - For bottom-sheet modals: use `items-end md:items-center` on the fixed container, `rounded-t-2xl md:rounded-2xl` on the modal panel, `max-h-[90vh] overflow-y-auto` for scrollable content
  - ScoreIndicator rating label hidden on mobile with `hidden sm:inline` — the bars alone provide the visual score information
  - layoutId animations on mobile bottom bar (`mobile-nav-indicator`) are separate from desktop nav (`nav-indicator`) to prevent cross-render conflicts
  - `safe-area-bottom` utility uses `env(safe-area-inset-bottom, 0px)` — needs viewport meta tag with `viewport-fit=cover` in layout.tsx for iOS Safari
  - Browser verification not available — manual testing needed
---
---
